iYou are carrying:Tricorder (#22140)                 [MOOSpace] Generic Interstellar Cra[MOOSpace] Generic Space Object (# [MOOSpace] Generic Astrophysical An[MOOSpace] Generic Universe (#1604 [MOOSpace] Generic Wormhole (#21733[MOOSpace] Generic Heavenly Body ( @dump gu;#16043.("permitted") = {};#16043.("noperms_msg") = "";#16043.("pnames") = {};#16043.("pdescs") = {};#16043.("pvalues") = 0;#16043.("p_shapes") = {"sphere", "ellipsoid", "torus", "elliptical torus"};#16043.("pdetails") = {};#16043.("entrances") = {};#16043.("exits") = {};#16043.("key") = 0;#16043.("aliases") = {"[MOOSpace] Generic Universe", "gu"};#16043.("description") = "A universe in MOOSpace is basically a container for all the space objects within it--a room of rooms that you have to imagine is infinite in extent. According to Richard Bartle, this is the sort of act of fancy that makes text-based virtual worlds superior to graphics-based ones. Universes also have regional features, called phenomena, that can affect starship navigation in various ways. Generally speaking, you won't need to create children of this object (or more than one, at least) unless you want to have your own dimension for ships, etc. to explore. Theoretically, you could create a whole series of universes and string them together into a multiverse, but it would take someone quite a long time to explore it!";#16043.("object_size") = {35743, 1295742401}"#16043.("original_owner") => E_PERM (Permission denied)"#16043.("days_left") => E_PERM (Permission denied);#16043.("creation_date") = 969427835"#16043.("queued_task_limit") => E_PERM (Permission denied)@args #16043:"@add-p*henomenon @addp*henomenon @remove-p*henomenon @removep*henomenon @rm-p*henomenon @rmp*henomenon" any none none@program #16043:@add-phenomenon"Usage:  @add-phenomenon <name> | @remove-phenomenon <name>";"  Adds or removes a cosmic phenomenon to this universe. A phenomenon is an area of space defined according to its shape. The default shapes are sphere, ellipsoid, torus, and elliptical torus. Additional shapes may be defined. A ship within the boundaries of a phenomenon will see a different name and description when it scans its present position in space. Use phenomena for such things as galaxies, star systems, nebulae, or whatever other weird things you can devise. Since phenomena can overlap, you can rearrange them or even add speed limits for ships traveling through them using the @set-phenomenon command.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());*** More ***  59 lines left.  Do @more [rest|flush] for more.@more r  return E_PERM;endifif (!dobjstr)  return player:tell("Usage: @", (verb[2] == "r") ? "remove-phenomenon" | "add-phenomenon", " <name>");endifname = dobjstr;if (verb[2] == "r")  if (this:remove_phenomenon(name))    player:tell(name, " has been removed from ", this:title(), ".");  else    player:tell("There is no phenomena called ", name, " defined on ", this:title(), ".");  endifelseif (verb[2] == "a")  if (results = this:match_phenomenon(name))    index = results[1];    question = (length(results) == 1) ? ((("There is a phenomenon called " + this.pnames[index]) + " already defined on ") + this:title()) + ". Do you want to write a new description for it? Answer 'yes' to replace the description. Otherwise a new phenomenon will be created." | (((((("There are " + length(results)) + " phenomena with the name ") + this.pnames[index]) + " already defined on ") + this:title()) + ". Do you want to write a new description for them? Answer 'yes' to replace the descriptions. Otherwise, a new phenomenon will be created.");    if ($string_utils:find_prefix($command_utils:read(player:tell(question)), {"yes", "1"}))      desc = $command_utils:read_lines(player:tell("Enter a new description for ", this.pnames[index], ":"));      for p in (results)        this.pdescs[p] = desc;        $command_utils:suspend_if_needed(0);      endfor      return player:tell("Description changed.");    endif  endif  player:tell("Enter a description for ", name, ":");  desc = $command_utils:read_lines();  shape = 0;  "If you want to define additional shapes, you should: 1. append the name of the shape as a string to this.p_shapes, 2. create a verb with the same name, replacing any spaces between words with underscores so the verb can be called internally, 3. program the verb collect the necessary values from the player to create the shape and store them in this.pvalues (see the original shape verbs for guidance), 4. create a verb called [shape]_contains where [shape] is the same name used above, and 5. program that verb to take as arguments a list of spherical coordinates in {radius, azimuth, inclination} form and a list of values from this.pvalues and return true if the coordinates are inside the specified phenomenon and false otherwise. This is easier than it sounds.";  while ((shape < 1) || (shape > length(this.p_shapes)))    player:tell("What shape do you want ", name, " to have? Enter a number:");    player:tell();    for sh in [1..length(this.p_shapes)]      player:tell(sh, ". ", this.p_shapes[sh]);    endfor    shape = toint($command_utils:read());  endwhile  shape_name = this.p_shapes[shape];  if ($object_utils:has_callable_verb(this, shape_name = $string_utils:substitute(shape_name, {{" ", "_"}})))    verb = shape_name;    this:(verb)(name, desc);  else    player:tell(this:title(), " is not capable of creating a ", shape_name, ". Command aborted.");    return;  endif  player:tell("A phenomenon called ", name, " shaped like ", ($string_utils:a_or_an(shape_name) + " ") + $string_utils:substitute(shape_name, {{"_", " "}}), " has been added to ", this:title(), ".");endif"LMB #23230 01/18/2011";.@args #16043:"@pheno*mena" none none none@program #16043:@phenomena"Usage:  @phenomena";"  Lists the phenomena defined on this universe and their details.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (this.pnames == {})  player:tell("There are no phenomena defined on ", this:title(), ".");else  player:tell("Phenomena defined on ", this:title(), " (bottom to top):");  index = 0;  for p in (this.pnames)    index = index + 1;    coordinates = ((((("(" + tostr(this.pvalues[index][1][1])) + ", ") + tostr(this.pvalues[index][1][2])) + ", ") + tostr(this.pvalues[index][1][3]))  + ")";    shape = this.p_shapes[this.pvalues[index][3]];    limit_text = ((limit = this.pvalues[index][4]) > 0) ? "a speed limit of warp " + tostr(limit) | "no speed limit";    player:tell(index, ". ", p, " with origin point at coordinates ", coordinates, " shaped like ", $string_utils:a_or_an(shape), " ", shape, " and with ", limit_text, ".");    if (data_string = this:phenomenon(index))      player:tell("   " + data_string);    endif    if ($list_utils:flatten(this.pdetails[index]))      details = {};      for pd in (this.pdetails[index][1])        details = {@details, pd};        $command_utils:suspend_if_needed(0);      endfor      player:tell("   Details defined on ", p, ": ", $string_utils:english_list(details), ".");    endif    $command_utils:suspend_if_needed(0);  endforendif"LMB #23230 01/19/2011";.@args #16043:"distance" this none this@program #16043:distance"Converts two sets of spherical coordinates into Cartesian coordinates and calculates the distance between them. You can hack this procedure for your universe if you want to define your own physics.";{x1, y1, z1} = this:convert(args[1]);{x2, y2, z2} = this:convert(args[2]);distance = sqrt((((x2 - x1) ^ 2.0) + ((y2 - y1) ^ 2.0)) + ((z2 - z1) ^ 2.0));"Because of the limitations of floating point calculations, it is necessary to reduce the precision of the extremely long decimals that will sometimes result from this procedure.";return tofloat(floatstr(distance, 10));"LMB #23230 01/08/2011";.@args #16043:"convert aconvert" this none this@program #16043:convert"The convert() function converts spherical into Cartesian coordinates, and aconvert() is vice versa. The positive x-axis in Cartesian is identical to the projection of 0 degrees of azimuth (theta) in the spherical system, and the positive y-axis is identical to the projection of 0 degrees of inclination (phi).";if (verb == "convert")  {r, theta, phi} = args[1];  if (((!(r >= 0.0)) || (!((theta >= 0.0) && (theta < 360.0)))) || (!((phi >= 0.0) && (phi <= 180.0))))    return E_INVARG;  else    theta = this:radians(theta);    phi = this:radians(phi);    x = (r * cos(theta)) * sin(phi);    y = (r * sin(theta)) * sin(phi);    z = r * cos(phi);    return {x, y, z};  endifelseif (verb == "aconvert")  {x, y, z} = args[1];  r = sqrt(((x ^ 2.0) + (y ^ 2.0)) + (z ^ 2.0));  theta = atan(y, x);  phi = acos(z / r);  "atan() returns a value between -pi and pi, but MOOSpace uses 360 degrees for azimuth, so any values less than zero (that is, in the range 0 to -180 degrees) are simply subtracted from 360 after conversion from radians to degrees.";  theta = (theta < 0.0) ? 360.0 - abs(this:degrees(theta)) | this:degrees(theta);  phi = this:degrees(phi);  return {r, theta, phi};endif"LMB #23230 01/08/2011";.@args #16043:"degrees" this none this@program #16043:degrees@dump gso*** More ***  264 lines left.  Do @more [rest|flush] for more.@more r*** buffer overflow, lines flushed ***"  Add or remove the name of a phenomenon shape to the shape name list of this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  return player:tell("Usage:  @", (verb[2] == "r") ? "remove-shape" | "add-shape", " <shape name>");endifshape = argstr;if (verb[2] == "r")  if (index = $string_utils:find_prefix(shape, this.p_shapes))    if (index < 5)      player:tell(this.p_shapes[index], " cannot be removed.");    else      player:tell(this.p_shapes[index], " removed.");      player:tell("If you created any phenomena with the shape ", this.p_shapes[index], ", you must remove them manually. Otherwise, they will be treated as spheres.");      this.p_shapes = listdelete(this.p_shapes, index);    endif  else    player:tell("No shape called ", shape, " has been defined on ", this:title(), ".");  endifelseif (verb[2] == "a")  this.p_shapes = {@this.p_shapes, shape};  player:tell(shape, " has been added to the phenomena shapes list for ", this:title(), ".");endif"LMB #23230 01/15/2011";.@args #16043:"sphere_contains ellipsoid_contains torus_contains elliptical_torus_contains" this none this@program #16043:sphere_contains"Determines whether or not a given point is within the boundaries of a phenomenon with relevant data from this.pvalues.";{data, point} = args;result = 0;if (verb == "sphere_contains")  {x, y, z} = this:convert(point);  {r} = data;  result = ((((x ^ 2.0) + (y ^ 2.0)) + (z ^ 2.0)) <= (r ^ 2.0)) ? 1 | 0;elseif (verb == "ellipsoid_contains")  {a, b, c} = data;  {r, theta, phi} = point;  theta = this:radians(theta);  phi = this:radians(phi);  op1 = (((r ^ 2.0) * (cos(theta) ^ 2.0)) * (sin(phi) ^ 2)) / (a ^ 2.0);  op2 = (((r ^ 2.0) * (sin(theta) ^ 2.0)) * (sin(phi) ^ 2)) / (b ^ 2.0);  op3 = ((r ^ 2.0) * (cos(phi) ^ 2.0)) / (c ^ 2.0);  result = (((op1 + op2) + op3) <= 1.0) ? 1 | 0;elseif (verb == "torus_contains")  {x, y, z} = this:convert(point);  {c, r} = data;  result = (((c - (sqrt((x ^ 2.0) + (y ^ 2.0)) ^ 2.0)) + (z ^ 2.0)) <= (r ^ 2)) ? 1 | 0;elseif (verb == "elliptical_torus_contains")  {x, y, z} = this:convert(point);  {a, b, c} = data;  op1 = (((((a ^ 2.0) * (((z ^ 2.0) / (b ^ 2.0)) - 1.0)) - (c ^ 2.0)) + (x ^ 2.0)) + (y ^ 2.0)) ^ 2.0;  op2 = ((4.0 * (a ^ 2.0)) * (c ^ 2.0)) * (1.0 - ((z ^ 2.0) / (b ^ 2.0)));  return (op1 <= op2) ? 1 | 0;endifreturn result;"LMB #23230 01/19/2011";.@args #16043:"@shapes" none none none@program #16043:@shapes"Usage:  @shapes";"  Lists the available phenomena shapes defined on this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifplayer:tell("Phenomena shapes defined on ", this:title(), ":");for shape in (this.p_shapes)  player:tell(shape);  $command_utils:suspend_if_needed(0);endfor"LMB #23230 01/15/2011";.@args #16043:"remove_phenomenon_detail" this none this@program #16043:remove_phenomenon_detail"Takes as arguments the name of a detail and the name of a phenomenon. Deletes all details that match the given detail name from all phenomena that match the given phenomenon name. Returns two lists, the names of the details deleted and the names of the phenomena deleted. This is a redundant step but designed to remind the player that redundant details are being deleted.";detail = args[1];ph = args[2];ph_list = this:match_phenomenon(ph);detail_list = this:match_phenomenon_detail(detail, ph_list);ph_names = {};detail_names = {};index = 0;for p in (detail_list[1])  index = index + 1;  d = detail_list[2][index];  ph_names = {@ph_names, this.pnames[p]};  detail_names = {@detail_names, this.pdetails[p][1][d]};  this.pdetails[p][1] = listdelete(this.pdetails[p][1], d);  this.pdetails[p][2] = listdelete(this.pdetails[p][2], d);  if (!$list_utils:flatten(this.pdetails[p]))    this.pdetails[p] = $list_utils:flatten(this.pdetails[p]);  endif  $command_utils:suspend_if_needed(0);endforreturn {detail_names, ph_names};"LMB #23230 01/17/2011";.@args #16043:"match_phenomenon" this none this@program #16043:match_phenomenon"Takes as an argument the name of a phenomenon and returns as a list the indexes of all the phenomena that match it which are stored in this.pnames.";ph = args[1];results = {};index = 0;for p in (this.pnames)  index = index + 1;  if (match(p, ph))    results = {@results, index};  endif  $command_utils:suspend_if_needed(0);endforreturn results;"LMB #23230 01/17/2011";.@args #16043:"match_phenomenon_detail" this none this@program #16043:match_phenomenon_detail"Takes as arguments the name of a detail to match and a list of indexes to phenomena stored in this.pnames and usually returned from this:match_phenomenon(). Returns a list of two lists. Each item in the first list is the the index number of a phenomenon that corresponds to the same element in the second list, which is the index number of a detail defined for that phenomenon. E.g., if this function returns {{1, 2}, {1, 1}}, then detail 1 on phenomena 1 (this.pnames[1]) and detail 1 on phenomena 2 match the given detail name. This could have been done in a more straightforward way. Maybe in the next version.";detail = args[1];ph_list = args[2];ph = {};details = {};index = 0;for p_index in (ph_list)  index = 0;  if (this.pdetails[p_index])    for d in (this.pdetails[p_index][1])      index = index + 1;      if (match(d, detail))        ph = {@ph, p_index};        details = {@details, index};      endif      $command_utils:suspend_if_needed(0);    endfor  endif  $command_utils:suspend_if_needed(0);endforreturn {ph, details};"LMB #23230 01/17/2011";.@args #16043:"@clear-phenomena-details @clearphenomenadetails @clear-ph-details @clearphdetails" any any any@program #16043:@clear-phenomena-details"Usage:  @clear-phenomena-details <phenomenon> | @clear-phenomena-details";"  With a phenomenon as an argument, clears all the details from that phenomenon. If no argument is given, all the details for all phenomena are cleared from this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!this.pnames)  return player:tell("There are no phenomena defined on ", this:title(), ".");elseif ($list_utils:flatten(this.pdetails) == {})  return player:tell("There are no details for any phenomena defined on ", this:title(), ".");endifif (!args)  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details from all the phenomena defined on ", this:title(), "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for p in [1..length(this.pnames)]      if (this.pdetails[p])        for d in [1..length(this.pdetails[p][1])]          player:tell(this.pdetails[p][1][d], " cleared from ", this.pnames[p], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[p] = {};        player:tell("All details cleared from ", this.pnames[p], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelseif (ph = this:match_phenomenon(argstr))  if ($list_utils:flatten(this.pdetails[ph[1]]) == {})    return player:tell("There are no details defined on ", this.pnames[ph[1]], ".");  endif  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details defined on ", this.pnames[ph[1]], "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for ph_index in (ph)      if (this.pdetails[ph_index])        details = length(this.pdetails[ph_index][1]);        for d in [1..details]          player:tell(this.pdetails[ph_index][1][d], " cleared from ", this.pnames[ph_index], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[ph_index] = {};        player:tell("All details cleared from ", this.pnames[ph_index], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelse  player:tell("There is no phenomenon called ", argstr, " defined on ", this:title(), ".");endif"LMB #23230 01/18/2011";.@args #16043:"phenomenon" this none this@program #16043:phenomenonindex = args[1];name = this.pnames[index];data = this.pvalues[index][2];shape_index = this.pvalues[index][3];shape = this.p_shapes[shape_index];string = "";if (shape == "sphere")  string = ((name + " has a radius of ") + tostr(data[1])) + ".";elseif (shape == "ellipsoid")  string = ((name + " has three semiaxes of lengths ") + $string_utils:english_list(data)) + ". ";elseif (shape == "torus")  string = ((((name + " has a radius of ") + tostr(data[1])) + " and its tube has a radius of ") + tostr(data[2])) + ".";elseif (shape == "elliptical_torus")  string = ((((((name + " has two semiaxes of lengths ") + tostr(data[1])) + " and ") + tostr(data[2])) + " and a radial semiaxis of ") + tostr(data[3])) + ".";endifreturn string;"LMB #23230 01/19/2011";."***finished***@chmod #7466."permitted" r;#7466.("permitted") = {};#7466.("oname") = "[MOOSpace] Generic Space Object (outside)";#7466.("odescription") = {"This is the parent object for the MOOSpace system. Verbs and properties common to all space objects--such as spaceships, planets, and strange phenomena--reside here. You should not normally create children of this object, because they will not have any functionality, but you can create new classes of space objects from it if you desire. See the appropriate help for descendents of this object for more information:", "", "Generic Interstellar Craft: help #19950", "Generic Heavenly Body: help #7771", "Generic Cosmic Phenomenon: help #9602", "Generic Universe: help #16043", "", "MOOSpace Basic Information: help #13676", "Generic Space Object is a child of the Improved Generic-All-In-One Room: help #7424"};#7466.("valid_space_object") = 0;#7466.("coordinates") = {0.0, 0.0, 0.0};#7466.("universe") = 0;#7466.("cloaked") = 0;#7466.("w_time") = 975830400;#7466.("w_prog") = 6;#7466.("entrances") = {};#7466.("blessed_task") = 1815215361;#7466.("exits") = {};#7466.("blessed_object") = #119;#7466.("key") = 0;#7466.("aliases") = {"[MOOSpace] Generic Space Object", "gso"};#7466.("description") = "This is the inside of the MOOSpace Generic Space Object. What are you doing here? Go somewhere else and look at this object again for help.";#7466.("object_size") = {14346, 1295742401}"#7466.("original_owner") => E_PERM (Permission denied)"#7466.("days_left") => E_PERM (Permission denied);#7466.("creation_date") = 1290635626"#7466.("queued_task_limit") => E_PERM (Permission denied)@args #7466:"perm_check" this none this@program #7466:perm_check"Takes a single object as an argument, usually the value of caller if passed from the command line and caller_perms() otherwise. Returns true if the object (typically a player) is this, this.owner, listed in this.permitted, or a wizard. Returns false otherwise or if the argument list is the wrong length. This is a permissions check meant to prevent verb spoofing. Every command verb defined on MOOSpace objects should use it. Since it's so important, perm_check() does considerable maintenance on this.permitted whenever it's called.";{?TestCase = 0, @rest} = args;if (!$perm_utils:controls(caller_perms(), this))  return E_PERM;elseif ((typeof(TestCase) != OBJ) || rest)  return E_ARGS;elseif (!$object_utils:has_property(this, "permitted"))  player:tell("** ERROR: The .permitted property on ", this.name, " is either missing or broken.");  return $perm_utils:controls(caller_perms(), this);elseif (typeof(this.permitted) != LIST)  this.permitted = {};endiftrusted_list = {#23230, this};permitted_list = this.permitted;"The for loop below makes sure the objects in this.permitted are valid (i.e. they exist and haven't been recycled) and cleans it up if necessary.";for trusted_object in (permitted_list = $list_utils:remove_duplicates($list_utils:flatten(permitted_list)))  $command_utils:suspend_if_needed(0);  if ((typeof(trusted_object) == OBJ) && $recycler:valid(trusted_object))    trusted_list = {@trusted_list, trusted_object};  else    permitted_list = setremove(permitted_list, trusted_object);  endifendforthis.permitted = permitted_list;return ((TestCase in trusted_list) || $perm_utils:controls(TestCase, this)) || $perm_utils:controls(caller_perms(), this);"LMB #23230 01/21/2011";.@args #7466:"look_self" this none this@program #7466:look_self"Displays different names and descriptions depending on the location of the calling player--the 'o' name and description if the player is outside of the object, and the regular ones otherwise.";if ($object_utils:contains(this, player))  pass(@args);else  player:tell(this:oname());  player:tell_lines(this:odescription());endif"LMB #23230 12/08/2010";.@args #7466:"oname odescription" this none this@program #7466:oname"Verb -> property matching for messages defined on this object. You can make your own versions of these verbs if you want to implement fancy formatting.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 12/08/2010";.@args #7466:"@permit @trust" any any any@program #7466:@permit"Usage:  @permit <any player> | @permit -<any player>";"  Commissions a player other than the owner to operate or modify this space object. Only the owner, however, can use this command. Use a minus sign '-' in front of the player's name to decommission that player";if (!$perm_utils:controls(caller, this))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  permitted_list = {this.owner, @this.permitted};  player:tell($string_utils:title_list(permitted_list), (permitted_list == {this.owner}) ? " is " | " are ", $string_utils:pronoun_sub("permitted to operate and modify %t."));elseif (dobjstr[1] == "-")  match = $string_utils:match(dobjstr[2..$], {this.owner, @this.permitted}, "aliases");  if (match == this.owner)    player:tell("You cannot decommission yourself!");  elseif (match in this.permitted)    this.permitted = setremove(this.permitted, match);    player:tell(match:title(), $string_utils:pronoun_sub(" is no longer commissioned to operate or modify %t."));  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  else    player:tell(dobjstr, $string_utils:pronoun_sub(" is not the name of any player currently commissioned to operate and modify %t."));  endifelse@dump ghb*** More ***  157 lines left.  Do @more [rest|flush] for more.*** More ***  157 lines left.  Do @more [rest|flush] for more.*** More ***  232 lines left.  Do @more [rest|flush] for more.*** More ***  232 lines left.  Do @more [rest|flush] for more.@more r  match = $string_utils:match_player(tostr(dobjstr));  if (match == $failed_match)    player:tell("No player called ", dobjstr, " can be found. Try using the player's object number instead.");  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  elseif (match in {@this.permitted, this.owner})    player:tell(match:title(), $string_utils:pronoun_sub(" is already permitted to operate and modify %t."));  else    this.permitted = {@this.permitted, match};    player:tell(match:title(), $string_utils:pronoun_sub(" is now commissioned to operate and modify %t."));  endifendif"LMB #23230 12/12/2010";.@args #7466:"moveto" this none this@program #7466:movetoif (!this:perm_check(caller))  player:tell("Gravity discourages you from even attempting that.");  return;endifreturn pass(@args);"LMB #23230 01/09/2011";.@args #7466:"valid_space_object" this none this@program #7466:valid_space_object"Returns 1 if this object, or the dobj if provided, has been properly initialized to work with MOOSpace and 0 otherwise. You can create your own version of this verb if you want more specialized space objects to satisfy additional conditions.";if (args)  dobj = args[1];  return ($object_utils:isa(dobj, #7466) && dobj.valid_space_object) ? 1 | 0;endifreturn ($object_utils:isa(this, #7466) && this.valid_space_object) ? 1 | 0;"LMB #23230 01/15/2011";.@args #7466:"universe universe_desc" this none this@program #7466:universe"Returns either the name of this universe or the name of the phenomenon in which the caller is located.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifcoordinates = this.coordinates;pinfo = (verb == "universe") ? this.universe:title() | this.universe:description();called_verb = verb;for p in (this.universe.pvalues)  shape = p[3];  verb_name = this.universe.p_shapes[shape] + "_contains";  verb = $object_utils:has_callable_verb(this.universe, verb_name) ? verb_name | "sphere_contains";  data = p[2];  if (this.universe:(verb)(data, coordinates))    index = p in this.universe.pvalues;    pinfo = (called_verb == "universe") ? this.universe.pnames[index] | this.universe.pdescs[index];  endif  $command_utils:suspend_if_needed(0);endforreturn pinfo;"LMB #23230 01/21/2011";.@args #7466:"initialize" this none this@program #7466:initialize"A space object must be initialized before it can interact with the MOOSpace system. Initialization sets a few necessary default values based on user input. To initialize a spaceship, visit the San Francisco Shipyards adjacent to Starfleet Headquarters. To initialize a heavenly body, you must find the planet Magrathea. If you want to create anomalies and other phenomena, you'll have to do a bit more exploring on your own.";"LMB #23230 01/19/2011";.@args #7466:"@cloak" any any any@program #7466:@cloak"Usage:  @cloak <on> or <off> | @cloak";"  Cloaks or uncloaks this space object. A cloaked object will be invisible to other ships when they scan. Without 'on' or 'off' as an argument, reports the current cloak status.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  status = (this.cloaked == 1) ? " is currently " | " is not currently ";  player:tell(this:title(), status, "cloaked.");elseif (argstr == "on")  if (this.cloaked == 1)    player:tell(this:title(), " is already cloaked.");  else    this.cloaked = 1;    player:tell(this:title(), " is now cloaked.");    this:announce(player:title(), " has activated the cloaking device!");    this:range_update(this.in_range);  endifelseif (argstr == "off")  if (this.cloaked == 0)    player:tell(this:title(), " is not currently cloaked.");  else    this.cloaked = 0;    player:tell(this:title(), " is no longer cloaked.");    this:range_update(this.in_range);    this:announce(player:title(), " has deactivated the cloaking device.");  endifelse  player:tell("Usage:  @cloak <on> or <off> | @cloak");endif"LMB #23230 01/22/2011";.@args #7466:"location_report" this none this@program #7466:location_report{r, theta, phi} = this.coordinates;r = tostr(r);theta = tostr(theta);phi = tostr(phi);return ((((("(" + theta) + " mark ") + phi) + " at ") + r) + " light years)";"LMB #23230 01/22/2011";.;#7771.("trusted_ships") = {};#7771.("not_trusted_ship_msg") = "Permission denied. Your ship is not trusted by %t.";#7771.("oname") = "[MOOSpace] Generic Heavenly Body";#7771.("odescription") = {"This is the parent of all heavenly bodies in the MOOSpace system. To create one for yourself, seek out the planet-builders of Magrathea."};#7771.("w_time") = 948960000;#7771.("w_prog") = 1;#7771.("entrances") = {};#7771.("blessed_task") = 1815215361;#7771.("exits") = {};#7771.("blessed_object") = #119;#7771.("key") = 0;#7771.("aliases") = {"[MOOSpace] Generic Heavenly Body", "ghb"};#7771.("description") = "This is the parent of all heavenly bodies in the MOOSpace system. To create one for yourself, seek out the planet-builders of Magrathea.";#7771.("object_size") = {6873, 1295742401}"#7771.("original_owner") => E_PERM (Permission denied)"#7771.("days_left") => E_PERM (Permission denied);#7771.("creation_date") = 969427645"#7771.("queued_task_limit") => E_PERM (Permission denied)@args #7466:"@oname" any none none@program #7466:@oname"Usage:  @oname <name> | @oname";"  Change or show the exterior display name of this space object.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  player:tell("Exterior display name of ", this.name, " (", this, ") is ", this:oname(), ".");else  name = argstr;  if (length(name) > 40)    return player:tell(tostr("That name is too long. The maximum number of characters allowed in a name is ", $login.max_player_name, "."));  endif  this.oname = name;  player:tell("Exterior display name of ", this.name, " (", this, ") changed to ", name, ".");endif"LMB #23230 01/22/2011";.@args #7771:"@add-sh*ip @addsh*ip @remove-sh*ip @removesh*ip @rm-sh*ip @rmsh*ip" any none none@program #7771:@add-ship"Usage:  @add-ship | @remove-ship <ship name or object number>";"  Grants or rescinds landing permission to a spaceship, which must be a descendant of Generic Interstellar Craft. If no ships are specifically given landing permission, then all ships have permission. If any ships are given permission with this command, only those ships will then have landing permission.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be modified. Type 'help #7466:initialize' for details.");endifif (!dobjstr)  return player:tell("Usage: @", (verb[2] == "r") ? "remove-ship" | "add-ship", " <ship name or object number>");endiftarget = (toobj(dobjstr) != #0) ? toobj(dobjstr) | dobjstr;if (verb[2] == "r")  if (typeof(target) == OBJ)    result = (target in this:trusted_ships()) ? target | $failed_match;  elseif (typeof(target) == STR)    result = $string_utils:match(target, this:trusted_ships(), "name");  endifelseif (verb[2] == "a")  if (typeof(target) == OBJ)    result = $object_utils:isa(target, #19950) ? target | $failed_match;  elseif (typeof(target) == STR)    result = $string_utils:match(target, $object_utils:descendants(#19950), "name");  endifendifif (result in this:trusted_ships())  if (verb[2] == "r")    this.trusted_ships = setremove(this.trusted_ships, result);    player:tell(result:title(), " is no longer permitted to ", $object_utils:isa(this, #19950) ? "dock at " | "land on ", this:title(), ".");    return;  endif  player:tell(result:title(), " has already been granted landing permission for ", this:title(), ".");elseif ((result == $failed_match) || (!result:valid_space_object()))  player:tell(dobjstr, " either doesn't exist or is not a valid ship.");elseif (result == $ambiguous_match)  player:tell(dobjstr, " can refer to more than one ship. Be more specific or use the ship's object number instead.");elseif (verb[2] == "a")  this.trusted_ships = {@this.trusted_ships, result};  land_or_dock = $object_utils:isa(this, #19950) ? "dock at" | "land on";  player:tell(result:title(), " is now permitted to ", land_or_dock, " ", this:title(), ".");endif"LMB #23230 01/19/2011";.@args #7466:"@odesc*ription" any any any@program #7466:@odescription"Usage:  @odescription <description> | @odescription";"  Change or show the exterior display description of this space object. Due to permissions checking with the note editor, I cannot make this any more robust. Sorry.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  player:tell("Exterior display description of ", this.name, " (", this, ") is:");  player:tell_lines(this:odescription());  if ($string_utils:find_prefix($command_utils:read(player:tell("Do you want to edit this description?")), {"yes", "1"}))    desc = $command_utils:read_lines();    this.odescription = desc;    player:tell("Exterior display description of ", this.name, " (", this, ") changed.");  else    player:tell("Exterior display description unchanged.");  endifelse  desc = argstr;  this.odescription = desc;  player:tell("Exterior display description of ", this.name, " (", this, ") changed.");endif"LMB #23230 01/22/2011";."***finished***@args #7771:"@ships" none none none@program #7771:@ships"Usage:  @ships";"  Displays the names of the ships currently permitted to land on this ship or heavenly body. If no ships are specified, then all ships are permitted to land.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be used. Type 'help #7466:initialize' for details.");endifships = this.trusted_ships;if (ships)  player:tell($string_utils:title_list(ships), (length(ships) == 1) ? " is " | " are ", "permitted to ", $object_utils:isa(this, #19950) ? "dock at " | "land on ", this:title(), ".");else  player:tell("Any ship may ", $object_utils:isa(this, #19950) ? "dock at " | "land on ", this:title(), ".");endif"LMB #23230 01/19/2011";.@args #7771:"not_trusted_ship_msg" this none this@program #7771:not_trusted_ship_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/19/2011";.@args #7771:"trusted_ships" this none this@program #7771:trusted_ships"Returns this.trusted_ships after cleaning it up.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());*** More ***  18 lines left.  Do @more [rest|flush] for more.@more r  return E_PERM;endiftrusted_list = {};trusted_ships = this.trusted_ships;for s in (trusted_ships)  if ((((typeof(s) == OBJ) && $recycler:valid(s)) && $object_utils:isa(s, #19950)) && s:valid_space_object())    trusted_list = {@trusted_list, s};  else    trusted_ships = setremove(trusted_ships, s);  endif  $command_utils:suspend_if_needed(0);endforthis.trusted_ships = trusted_ships;return trusted_list;"LMB #23230 01/19/2011";."***finished***@dump gic;#19950.("heading") = 0;#19950.("bearing") = {0.0, 0.0, 0.0};#19950.("speed") = 1;#19950.("in_range") = {{}, {}, {}, {}};#19950.("engage_origin_msg") = "You say, \"Engage!\" and %t powers up its engines.";#19950.("oengage_origin_msg") = "%n says, \"Engage!\" and %t powers up its engines.";#19950.("engage_arrive_msg") = "You have brought %t safely to its destination.";#19950.("oengage_arrive_msg") = "%t arrives safely at its destination.";#19950.("hail_origin_msg") = "You hail %d with: ";#19950.("ohail_origin_msg") = "%n hails %d with: ";#19950.("hail_receive_msg") = "%n hails from %t: ";#19950.("commander_msg") = "The crew stands at attention as you enter the bridge.";#19950.("ocommander_msg") = "The crew stands at attention as %n enters the bridge.";#19950.("launch_start_msg") = "You launch %t into space.";#19950.("olaunch_start_msg") = "%n launches %t into space.";#19950.("launch_start_outside_msg") = "%t rises into the air and blasts off into space.";#19950.("launch_end_msg") = "%t arrives safely in";#19950.("olaunch_end_msg") = "%n has successfully launched %t into";#19950.("board_msg") = "You board %t.";#19950.("oboard_msg") = "%n boards %t.";#19950.("oboard_depart_msg") = "%n has boarded %t.";#19950.("disembark_msg") = "You have disembarked from %t.";#19950.("odisembark_msg") = "%n has disembarked from %t for %l.";#19950.("odisembark_arrive_msg") = "%n disembarks from %t.";#19950.("land_start_msg") = "You lower the landing gear and prepare to land %t on";#19950.("oland_start_msg") = "%n lowers the landing gear and prepares to land %t on";#19950.("land_end_msg") = "You bring %t in for a smooth landing on";#19950.("oland_end_msg") = "%n brings %t in for a smooth landing on";#19950.("land_end_outside_msg") = "%t soars in from outer space and lands gracefully nearby.";#19950.("engines") = 0;#19950.("explored") = {};#19950.("scan_msg") = "A beam of light from %t scans you.";#19950.("oscan_msg") = "A beam of light from %t scans"*** More ***  21 lines left.  Do @more [rest|flush] for more.@more r;#19950.("disengage_msg") = "You disengage the engines and bring %t to a full stop.";#19950.("odisengage_msg") = "%n disengages the engines and brings %t to a full stop.";#19950.("oname") = "[MOOSpace] Generic Interstellar Craft";#19950.("odescription") = {"This is the parent of all spaceships in the MOOSpace system. To create one for yourself, visit the San Francisco Shipyards adjacent to Starfleet Headquarters."};#19950.("w_time") = 950428800;#19950.("w_prog") = 6;#19950.("entrances") = {};#19950.("blessed_task") = 1815215361;#19950.("exits") = {};#19950.("blessed_object") = #119;#19950.("key") = 0;#19950.("aliases") = {"[MOOSpace] Generic Interstellar Craft", "gic"};#19950.("description") = "This is the parent of all spaceships in the MOOSpace system. To create one for yourself, visit the San Francisco Shipyards adjacent to Starfleet Headquarters.";#19950.("object_size") = {36481, 1295742401}"#19950.("original_owner") => E_PERM (Permission denied)"#19950.("days_left") => E_PERM (Permission denied);#19950.("creation_date") = 969427497"#19950.("queued_task_limit") => E_PERM (Permission denied)@args #19950:"laun*ch" none none none@program #19950:launch"Usage:  launch";"  Launches this ship into whatever universe whatever heavenly body it is landed on is in.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be launched. Type 'help #7466:initialize' for details.");elseif ($object_utils:isa(this.location, #16043))  player:tell(this:title(), " has already been launched into ", this:universe(), ".");else  player:tell(this:launch_start_msg());  this:announce(this:olaunch_start_msg());  if (!this:command_launch())    player:tell("Launch failed. There must be a permissions conflict somewhere.");    this:announce("Launch attempt failed.");    return;  else    this.location:announce_all(this:launch_start_outside_msg());    player:tell(((this:launch_end_msg() + " ") + this:universe()) + ".");    this:announce(((this:olaunch_end_msg() + " ") + this:universe()) + ".");  endifendif"LMB #23230 01/21/2011";.@args #19950:"command_launch" this none this@program #19950:command_launchif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifthis:moveto(this.universe);if (this.location == this.universe)  old_range = this.in_range;  this:sensor_sweep();  this:range_update(old_range);  this:scan();  return 1;else  return 0;endif"LMB #23230 01/20/2011";.@args #19950:"sensor_sweep" this none this@program #19950:sensor_sweepif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifthis.in_range = {{}, {}, {}, {}};if (!$object_utils:isa(this.location, #16043))  return;endifset = {};contents = setremove(this.universe.contents, this);for o in (contents)  if (this:valid_space_object(o) && (!o.cloaked))@dump gaa*** More ***  309 lines left.  Do @more [rest|flush] for more.*** More ***  309 lines left.  Do @more [rest|flush] for more.*** More ***  351 lines left.  Do @more [rest|flush] for more.*** More ***  351 lines left.  Do @more [rest|flush] for more.*** More ***  375 lines left.  Do @more [rest|flush] for more.*** More ***  375 lines left.  Do @more [rest|flush] for more.@more r    set = {@set, o};  endif  $command_utils:suspend_if_needed(0);endformy_coordinates = this.coordinates;same = {};near = {};med = {};long = {};for x in (set)  their_coordinates = x.coordinates;  d = this.universe:distance(my_coordinates, their_coordinates);  if (d <= 10.0)    same = {@same, x};    this:exp(x);  elseif (d <= 100.0)    near = {@near, x};  elseif (d <= 1000.0)    med = {@med, x};  elseif (d <= 10000.0)    long = {@long, x};  endif  $command_utils:suspend_if_needed(0);endforthis.in_range = {same, near, med, long};"LMB #23230 01/21/2011";.@args #19950:"sensor_update" this none this@program #19950:sensor_updateif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifrange = this.in_range;{ship, switch} = args;if (switch == 0)  for r in [1..4]    for s in (range[r])      if (s == ship)        range = setremove(range[r], s);        break r;      endif      $command_utils:suspend_if_needed(0);    endfor    $command_utils:suspend_if_needed(0);  endfor  this.in_range = range;elseif (switch == 1)  ship_range = ship.in_range;  for r in [1..4]    for s in (ship_range[r])      if (s == this)        range = setadd(range[r], ship);        break r;      endif      $command_utils:suspend_if_needed(0);    endfor    $command_utils:suspend_if_needed(0);  endforendifthis.in_range = range;"LMB #23230 01/22/2011";.@args #19950:"look_self" this none this@program #19950:look_selfif (player.location == this)  pass(@args);  if (!$object_utils:isa(this.location, #16043))    viewscreen = ("[On Viewscreen: " + this.location:title()) + "]";    player:tell(viewscreen);  else    if (this.engines)      player:tell((((((this:title() + " is currently traveling with a bearing of ") + this:bearing_report()) + (this:heading_report() ? (" toward " + this:heading_report()) + " " | " ")) + "at warp ") + this.speed) + ".");    endif    viewscreen = ((("[On Viewscreen: " + this:universe()) + " ") + this:location_report()) + "]";    player:tell(viewscreen);  endifelse  pass(@args);endif"LMB #23230 01/22/2011";.@args #19950:"range_update" this none this@program #19950:range_updateif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif{p, q, r, s} = args[1];old_range = {@p, @q, @r, @s};if (typeof(this.in_range) == OBJ)  range = this.in_range;  total_range = old_range;else  {a, b, c, d} = this.in_range;  range = {@a, @b, @c, @d};  total_range = {@range, @old_range};endiffor x in (total_range)  if (($object_utils:isa(x, #19950) && $object_utils:isa(x.location, #16043)) && $set_utils:intersection(x.contents, connected_players()))    {x1, x2, x3, x4} = x.in_range;    xrange = {@x1, @x2, @x3, @x4};    if ((this in xrange) && $object_utils:isa(this.location, #7771))      x:announce_all((((this:oname() + " has ") + ($object_utils:isa(this.location, #19950) ? "docked at " | "landed on ")) + this.location:oname()) + ".");      x:sensor_update(this, 0);    elseif ((typeof(range) == OBJ) && $object_utils:isa(this.location, #21733))      x:announce_all(((this:oname() + " has crossed the event horizon of ") + this.location:oname()) + ".");      x:sensor_update(this, 0);    elseif ((typeof(range) == OBJ) && $object_utils:isa(this.location, #16043))      msg = $object_utils:isa(range, #21733) ? " has emerged from " + range:oname() | (" has launched into space from " + range:oname());      x:announce_all(msg + ".");      x:sensor_update(this, 1);    else      d = this.universe:distance(this.coordinates, x.coordinates);      if (((d < 10000.0) && (!(this in xrange))) && (this.cloaked == 0))        x:announce_all(this:oname(), " has entered sensor range.");        x:sensor_update(this, 1);      elseif (((d > 10000.0) || (this.cloaked == 1)) && (this in xrange))        x:announce_all(this:oname(), " is no longer in sensor range.");        x:sensor_update(this, 0);      endif    endif  endif  $command_utils:suspend_if_needed(0);endfor"LMB #23230 01/22/2011";.@args #19950:"sc*an" any none none@chmod #19950:scan rxd@program #19950:scan"Usage:  scan <any>";"  Without an argument, scans the local region of space, returning a description of the ship's surroundings, the names of any objects in sensor range, and the ship's absolute location with respect to the origin in the format (azimuth mark inclination at distance). With an object in range as an argument, scans that object. You can also scan visible phenomena more closely, like looking at details in a room description.";if (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be operated. Type 'help #7466:initialize' for details.");endif"This is very old code, but it works, so I didn't modify it very much.";this:sensor_sweep();this:announce(player:title(), " performs a sensor sweep of ", this:universe(), ".");if (!args)  if ($object_utils:isa(this.location, #16043))    player:tell((this:universe() + " ") + this:location_report());    player:tell_lines(this:universe_desc());    names = {};    if (length(this.in_range[1]) == 1)      x = this.in_range[1][1];      player:tell(x:oname(), " is in this sector.");    elseif (length(this.in_range[1]) > 1)      for n in (this.in_range[1])        names = {@names, n:oname()};      endfor      player:tell($string_utils:english_list(names), " are in this sector.");    endif    if (length(this.in_range[2]) == 1)      x = this.in_range[2][1];      player:tell(x:oname(), " is nearby.");    elseif (length(this.in_range[2]) > 1)      for n in (this.in_range[2])        names = {@names, n:onames()};      endfor      player:tell($string_utils:english_list(names), " are nearby.");    endif    if (length(this.in_range[3]) == 1)      x = this.in_range[3][1];      player:tell(x:oname(), " is in medium sensor range.");    elseif (length(this.in_range[3]) > 1)      for n in (this.in_range[3])        names = {@names, n.oname};      endfor      player:tell($string_utils:english_list(names), " are in medium sensor range.");    endif    if (length(this.in_range[4]) == 1)      x = this.in_range[4][1];      player:tell(x:oname(), " is in long sensor range.");    elseif (length(this.in_range[4]) > 1)      for n in (this.in_range[4])        names = {@names, n:onames()};      endfor      player:tell($string_utils:english_list(names), " are in long sensor range.");    endif  else    this:look_outside();  endifelse  if ($object_utils:isa(this.location, #16043))    "Handle phenomenon details.";    phenomenon = this:universe();    ph_index = (phenomenon == this.universe:title()) ? 0 | (phenomenon in this.universe.pnames);    if (ph_index)      details = this.universe.pdetails[ph_index];      match = $string_utils:find_prefix(argstr, details[1]);      if (match)        return player:tell_lines(details[2][match]);      elseif (ph = $string_utils:find_prefix(argstr, this.universe.pnames))        return player:tell_lines(this.universe.pdescs[ph]);      elseif ($string_utils:find_prefix(argstr, this.universe:title()))        player:tell_lines(this.universe:description());      endif    endif    {a, b, c, d} = this.in_range;    range = {@a, @b, @c, @d};    match = $string_utils:match(argstr, range, "oname");    if ((match == $failed_match) || (!this:valid_space_object(match)))      player:tell("There is no '", argstr, "' in sensor range.");    elseif (match == $ambiguous_match)      player:tell("'", argstr, "' can refer to more than one object in sensor range. Be more specific.");    else      player:tell(match:oname(), " ", match:location_report(), " is in ", match:universe(), ".");      player:tell_lines(match:odescription());      if ($object_utils:isa(match, #7771) && (!$object_utils:isa(match, #19950)))        player:tell(match:oname(), " is a heavenly body. Perhaps you can land on it?");      elseif ($object_utils:isa(match, #9602))        player:tell(match:oname(), " is some sort of astrophysical anomaly. Perhaps you can learn more about it?");      elseif ($object_utils:isa(match, #19950) && match.engines)        player:tell(match:oname(), " is traveling with a bearing of ", match:bearing_report(), " at warp ", match.speed, ".");      endif    endif  else    range = this.location.contents;    match = $string_utils:match(argstr, range, "aliases");    if (match == $failed_match)      player:tell("There is no '", argstr, "' in ", this.location:title(), ".");    elseif (match == $ambiguous_match)      player:tell("'", argstr, "' can refer to more than one object in ", this.location:title(), ". Be more specific.");    else      match:look_self();      if (is_player(match) && (match in connected_players()))        match:tell(this:scan_msg());        match.location:announce_all_but({match}, ((this:oscan_msg() + " ") + match:title()) + ".");      endif    endif  endifendif"LMB #23230 01/22/2011";.;#9602.("oname") = "[MOOSpace] Generic Astrophysical Anomaly";#9602.("odescription") = {"This is the parent of all astrophysical anomalies in the MOOSpace system. To create one for yourself, you'll have to do lots of exploring."};#9602.("w_time") = 948614400;#9602.("entrances") = {};#9602.("blessed_task") = 1815215361;#9602.("exits") = {};#9602.("blessed_object") = #119;#9602.("key") = 0;#9602.("aliases") = {"[MOOSpace] Generic Astrophysical Anomaly", "gaa"};#9602.("description") = "This is the parent of all astrophysical anomalies in the MOOSpace system. To create one for yourself, you'll have to do lots of exploring.";#9602.("object_size") = {3229, 1295742401}"#9602.("original_owner") => E_PERM (Permission denied)"#9602.("days_left") => E_PERM (Permission denied);#9602.("creation_date") = 969427652"#9602.("queued_task_limit") => E_PERM (Permission denied)@args #19950:"lan*d" any none none@program #19950:land"Usage:  land <location>";"  Lands the ship at the specified location, if possible. Only trusted ships may land at locations where the trusted ship list is not empty.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be launched. Type 'help #7466:initialize' for details.");elseif (!$object_utils:isa(this.location, #16043))  player:tell(this:title(), " is already landed on ", this.location:title(), ".");elseif (!args)  return player:tell("Usage:  land <location>");else  range = this.in_range[1];  planet = argstr;  match = $string_utils:match(planet, range, "oname");  all_range = $list_utils:flatten(this.in_range);  out_of_range = $string_utils:match(planet, $set_utils:difference(all_range, range), "oname");  if (out_of_range)    return player:tell(this:title(), " must be in the same sector as ", out_of_range:oname(), " in order to attempt landing on it.");  endif  if ((match == $failed_match) || (!this:valid_space_object(match)))    player:tell("There is no '", planet, "' in this sector.");  elseif (match == $ambiguous_match)    player:tell("'", planet, "' can refer to more than one object in sensor range. Be more specific.");  elseif (!$object_utils:isa(match, #7771))    player:tell(match:oname(), " cannot be landed on.");  elseif (match:trusted_ships() && (!(this in {@#8510, match:trusted_ships()})))    player:tell(this:title(), " is not permitted to land at ", match:oname(), ".");  else    player:tell(((this:land_start_msg() + " ") + match:oname()) + ".");    this:announce(((this:oland_start_msg() + " ") + match:oname()) + ".");    if (this:command_land(match))      player:tell(((this:land_end_msg() + " ") + match:oname()) + ".");      this:announce(((this:oland_end_msg() + " ") + match:oname()) + ".");      this.location:announce(this:land_end_outside_msg());      this.in_range = this.location;    else      player:tell(this:title(), " cannot seem to land at ", match:oname(), ". There might be a permissions problem or else ", match:oname(), " doesn't want you.");      this:announce($object_utils:isa(match, #19950) ? "Dock" | "Land", " attempt failed.");    endif  endifendif"LMB #23230 01/22/2011";.@args #9602:"app*roach" this none none@program #9602:approach"Usage:  approach <this>";"  Activates this astrophysical anomaly. The results are unpredictable.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endifif (this:valid_space_object())  if (!this:activate())    player:tell("Nothing happens.");  endifendif"LMB #23230 01/22/2011";.@args #19950:"command_land" this none this@program #19950:command_landif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifplanet = args[1];this:moveto(planet);if (this.location == planet)  old_range = this.in_range;  this:range_update(old_range);  for x in ($list_utils:flatten(this.in_range))    docked_or_landed = $object_utils:isa(planet, #19950) ? " has docked at " | " has landed on ";    if ($object_utils:isa(x, #19950) && $set_utils:intersection(x.contents, connected_players()))      x:announce_all(this:title(), docked_or_landed, planet:oname(), ".");    endif    $command_utils:suspend_if_needed(0);  endfor  this:scan();  return 1;else  return 0;endif"LMB #23230 01/22/2011";.@args #9602:"activate" this none this@program #9602:activate"You must create your own version of this verb if you want this anomaly to do something.";return 0;"LMB #23230 01/22/2011";."***finished***@args #19950:"look_outside" this none this@program #19950:look_outsideplayer:tell_lines(this.location:title());desc = this.location:description();if (desc)  player:tell_lines(desc);else  player:tell("You see nothing special.");endifif ($object_utils:has_callable_verb(this.location, "tell_integration"))  this.location:tell_integration();endifthis.location:tell_contents(setremove(this.location.contents, this), 3);"LMB #23230 09/30/2000";.@args #19950:"ent*er bo*ard go" this none none@program #19950:enter"Usage:  enter <this>";"  Board the ship. If you have :moveto() protection, this command may not function.";if ((player.location == this) || $object_utils:isa(this.location, #16043))  player:tell("I don't understand that.");else  player:moveto(this);  if (player.location != this)    player:tell("You seem unable to board ", this:oname(), ". Make sure you don't have moveto() protection.");  else    player:tell(this:board_msg());    this:announce(this:oboard_msg());    this.location:announce(this:oboard_depart_msg());  endifendif"LMB #23230 01/22/2011";.@args #19950:"ex*it dis*embark out" none none none@program #19950:exit"Usage:  exit";"  Exit the ship. You cannot exit a ship while it is in space.";if (player.location != this)  return player:tell("I don't understand that.");endifif ($object_utils:isa(this.location, #16043))  player:tell("You cannot exit ", this:title(), " until it lands.");else  player:moveto(this.location);  if (player.location == this)    player:tell("You seem unable to exit ", this:title(), ". Make sure you don't have moveto() protection.");  else@dump gw*** More ***  264 lines left.  Do @more [rest|flush] for more.*** More ***  264 lines left.  Do @more [rest|flush] for more.*** More ***  334 lines left.  Do @more [rest|flush] for more.*** More ***  334 lines left.  Do @more [rest|flush] for more.@more r    player:tell(this:disembark_msg());    this:announce(this:odisembark_msg());    this.location:announce(this:odisembark_arrive_msg());  endifendif"LMB #23230 01/20/2011";.@args #19950:"enterfunc confunc" this none this@program #19950:enterfuncpass(@args);if (is_player(caller) && this:perm_check(caller))  player:tell(this:commander_msg());  this:announce(this:ocommander_msg());endif"LMB #23230 01/22/2011";.@args #19950:"sp*eed" any none none@program #19950:speed"Usage:  speed | speed <new speed>";"  Displays the current speed of the ship or sets a new one.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be launched. Type 'help #7466:initialize' for details.");endifif (!args)  player:tell(this:title(), " is currently set to travel at warp ", this.speed, ".");else  speed = tofloat(argstr);  if ((speed < 1.0) || (speed > 10.0))    player:tell("'", argstr, "' is an incorrect speed setting. ", this:title(), " can only be set to travel between warp 1 and warp 10.");  else    this.speed = tofloat(speed);    this.speed = speed;    player:tell(this:title(), " is now set to travel at warp ", speed, ".");    this:announce(player:title(), " set ", this:title(), " to travel at warp ", speed, ".");  endifendif"LMB #23230 01/21/2011";.@args #19950:"head*ing bear*ing" any any any@program #19950:heading"Usage:  bearing <radius> <azimuth> <inclination> | heading <destination>";"  There are two ways to navigate in MOOSpace. The first is to enter a bearing, which is a specific location to which you want to travel expressed in spherical coordinates. The radius is the absolute distance of the location from the origin point, the azimuth is the angle >= 0.0 and < 360.0 degrees between, e.g., the line pointing toward the center of the galaxy and the ship's direction of travel, and the inclination is the angle >= 0.0 and <= 180.0 degrees between, e.g., the line pointing toward the north pole of the galaxy and the ship's direction of travel, with 90.0 degrees being level with, e.g. the galactic plane (or however you want to imagine the structure of the universe). If you want to travel on a true bearing, you can enter a very high radius value, though it takes about a day to travel 100,000 light years if the task isn't killed. The second way to navigate is to enter a heading, which in this system is simply the name of a specific object, e.g. a planet or other heavenly body, toward which you wish to navigate. In order to navigate with a heading, you must have visited the named object before.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before the navigation system can be used. Type 'help #7466:initialize' for details.");elseif (!$object_utils:isa(this.location, #16043))  return player:tell(this:title(), " must be launched before its navigation system can be used.");elseif (!args)  msg = (this:title() + ((verb[1] == "b") ? " has a bearing of " + this:bearing_report() | (this.heading ? " is heading toward " + this:heading_report() | " does not currently have a heading"))) + ".";  return player:tell(msg);elseif ((verb[1] == "b") && (length(args) == 3))  {r, theta, phi} = args;  r = `tofloat(r) ! E_INVARG => 0';  theta = `tofloat(theta) ! E_INVARG => 0';  phi = `tofloat(phi) ! E_INVARG => 0';  if ((((((((r == 0) || (theta == 0)) || (phi == 0)) || (r < 0.0)) || (theta < 0.0)) || (theta >= 360.0)) || (phi < 0.0)) || (phi > 180.0))    player:tell("A bearing must be entered as three numbers: a radius greater than or equal to 0; an azimuth angle greater than or equal to 0 and less than 360; and an inclination angle greater than 0 and less than or equal to 180.");  else    this.bearing = {r, theta, phi};    player:tell(this:title(), " is now set with a bearing of ", this:bearing_report(), ".");    this:announce(player:title(), " has set ", this:title(), " with a bearing of ", this:bearing_report(), ".");  endifelseif (verb[1] == "h")  if (heading = this:find_heading(argstr))    this.heading = heading;    player:tell(this:title(), " is now set on a heading toward ", heading:oname(), ".");    this:announce(player:title(), " has set ", this:title(), " on a heading toward ", heading:oname(), ".");  elseif (heading == $failed_match)    player:tell("Your ship's navigation system does not know where '", argstr, "' is. Perhaps you haven't discovered it yet?");  elseif (heading == $ambiguous_match)    player:tell("'", argstr, "' can refer to more than one heading. Be more specific.");  endifelse  command = (verb[1] == "b") ? "bearing <radius> <azimuth> <inclination>" | "heading <destination>";  return player:tell("Usage:  ", command);endif"LMB #23230 01/22/2011";.@args #19950:"h*ail" any any any@program #19950:hail"Usage:  hail <ship> or <player> <message>";"  Send a message to another ship in sensor range. When landed, you can use this command to send a message to a player on the same planet as your ship.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can engage in ship to ship communications. Type 'help #7466:initialize' for details.");elseif (length(args) < 2)  return player:tell("Usage: hail <ship> or <player> <message>");endifmsg = "";if (!$object_utils:isa(this.location, #16043))  {recipient, @command} = args;  if ($set_utils:intersection(match = $string_utils:match_player(recipient), connected_players()))    msg = $string_utils:trim(command);    match:tell(player:title(), " hails from ", this:oname(), ": \"", msg, "\"");    player:tell("You hail ", match:title(), ".");  elseif (match == $ambiguous_match)    player:tell("'", argstr, "' can refer to more than one player. Be more specific.");  else    player:tell("There is no player called '", argstr, "' at ", this.location:title(), ".");  endifelse  command = argstr;  range = $list_utils:flatten(this.in_range);  match_list = {};  for r in (range)    name = r:oname() + "*";    if ($string_utils:match_string(command, name))      match_list = {@match_list, r};    endif    $command_utils:suspend_if_needed(0);  endfor  if (length(match_list) > 1)    player:tell("'", argstr, "' can refer to more than one ship within sensor range. Be more specific.");  elseif (!match_list)    player:tell("There is no ship called '", argstr, "' within sensor range.");  else    ship = match_list[1];    msg = $string_utils:match_string(command, ship:oname());    ship:announce_all(player:title(), "hails from ", this:oname(), ": \"", msg, "\"");    player:tell("You hail ", ship:oname(), ".");  endifendif"LMB #23230 01/22/2011";.@args #19950:"eng*age dis*engage" none none none@program #19950:engage"Usage:  engage | disengage";"  Activates or deactivates the ship's engines. When you engage the ships engines, it will proceed to travel at the current speed, which may be modified en route, until it arrives at the current bearing, which may also be modified en route.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before its engines can be engaged. Type 'help #7466:initialize' for details.");elseif (!$object_utils:isa(this.location, #16043))  player:tell(this:title(), " must be launched before its engines can be engaged.");else  if (verb[1] == "e")    if (this.engines)      return player:tell(this:title(), "'s engines are already engaged.");    endif    this.engines = 1;    player:tell(this:engage_origin_msg());    this:announce(this:oengage_origin_msg());    if (this:engines())      player:tell(this:engage_arrive_msg());      this:announce(this:oengage_arrive_msg());    else      this:announce_all(this:title(), " seems to be experiencing a warp drive malfunction. Engines disengaged.");    endif    this.engines = 0;  elseif (verb[1] == "d")    if (!this.engines)      return player:tell(this:title(), "'s engines are not currently engaged.");    endif    this.engines = 0;    player:tell(this:disengage_msg());    this:announce(this:odisengage_msg());  endifendif"LMB #23230 01/22/2011";.@args #19950:"engines" this none this@program #19950:enginesif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif"This function moves the ship using vector math.";"while (this.universe:distance(this.coordinates, this.bearing) > (this.speed))";"  speed = this.speed;";"  midpoint = this:midpoint(this.coordinates, this.bearing);";"  while (d = this.universe:distance(this.coordinates, midpoint) > (speed))";"    midpoint = this:midpoint(this.coordinates, midpoint);";"  endwhile";"  this.coordinates = midpoint;";"endwhile";" <----- OLD CODE ABOVE, NEW CODE BELOW ----->";while ((d = this.universe:distance(this.coordinates, this.bearing) > 0.0) && this.engines)  speed = this.speed;  {x1, y1, z1} = this.universe:convert(this.coordinates);  {x2, y2, z2} = this.universe:convert(this.bearing);  {xv, yv, zv} = this:normalize({x1, y1, z1}, {x2, y2, z2});  x = x1 + (speed * xv);  this:scan();  this:range_update(this.in_range);  y = y1 + (speed * yv);  z = z1 + (speed * zv);  this.coordinates = this.universe:aconvert({x, y, z});  this:range_update(this.in_range);  suspend(1);  if (d <= speed)    suspend(1);    this.coordinates = this.bearing;  endif  if ($command_utils:running_out_of_time())    this:announce_all(this:title(), " is passing through an unstable area of space and needs a moment to stabilize.");    suspend(60);    this:announce_all(this:title(), " has successfully stabilized.");  endifendwhilereturn (this.coordinates == origin) ? 0 | 1;"LMB #23230 01/22/2011";.;#21733.("activate_msg") = "You command %l to cross the event horizon of %t!";#21733.("oactivate_msg") = "%n commands %l to cross the event horizon of %t!";#21733.("destination") = #16043;#21733.("mouth") = {0.0, 0.0, 0.0};#21733.("emerge_msg") = "%l emerges from %t into";#21733.("oemerge_msg") = "%l emerges from %t into";#21733.("oname") = "[MOOSpace] Generic Wormhole";#21733.("odescription") = {"This is a parent object for wormholes in the MOOSpace system. A wormhole can lead to another part of its universe or to an entirely different universe."};#21733.("w_time") = 952848000;#21733.("w_prog") = 4;#21733.("entrances") = {};#21733.("blessed_task") = 1815215361;#21733.("exits") = {};#21733.("blessed_object") = #119;#21733.("key") = 0;#21733.("aliases") = {"[MOOSpace] Generic Wormhole", "gw"};#21733.("description") = "This is a parent object for wormholes in the MOOSpace system. A wormhole can lead to another part of its universe or to an entirely different universe.";#21733.("object_size") = {5961, 1295742401}"#21733.("original_owner") => E_PERM (Permission denied)"#21733.("days_left") => E_PERM (Permission denied);#21733.("creation_date") = 970429962"#21733.("queued_task_limit") => E_PERM (Permission denied)@args #19950:"commander_msg ocommander_msg launch_start_msg olaunch_start_msg launch_start_outside_msg launch_end_msg olaunch_end_msg board_msg oboard_msg oboard_depart_msg disembark_msg odisembark_msg odisembark_arrive_msg land_start_msg oland_start_msg land_end_msg oland_end_msg land_end_outside_msg scan_msg oscan_msg disengage_msg odisengage_msg engage_origin_msg oengage_origin_msg engage_arrive_msg oengage_arrive_msg" this none this@program #19950:commander_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/09/2011";.@args #21733:"activate" this none this@program #21733:activateif (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endifship = player.location;player:tell(this:activate_msg());ship:announce(this:oactivate_msg());if ($object_utils:isa(ship, #19950))  ship:moveto(this);  if (ship.location == this)    ship.in_range = this;    ship:range_update(this.in_range);    suspend(5);    ship:announce_all(this:description());    suspend(5);    if ($object_utils:isa(this.destination, #16043) && (typeof(this.mouth) == LIST))      ship:moveto(this.destination);      if (ship.location == this.destination)        ship.universe = this.destination;        ship.coordinates = this.mouth;        player:tell(((this:emerge_msg() + " ") + ship:universe()) + ".");        ship:announce(((this:oemerge_msg() + " ") + ship:universe()) + ".");        ship:scan();      else        ship:moveto(this.universe);        player:tell(((this:emerge_msg() + " ") + ship:universe()) + ".");        ship:announce(((this:oemerge_msg() + " ") + ship:universe()) + ".");        ship:scan();        ship:range_update(ship.in_range);      endif      return 1;    endif  endifendifreturn 0;"LMB #23230 01/22/2011";.@args #19950:"here_huh" this none this@program #19950:here_huh"Look for something to do on an astrophysical anomaly.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endif{verb, ?target = ""} = args;if (target && this:valid_space_object())  range = this.in_range[1];  anomaly = 0;  for o in (range)    if (($object_utils:isa(o, #9602) && match(o:title(), target)) && $object_utils:match_verb(o, verb))      anomaly = o;      verb = $object_utils:match_verb(o, verb)[2];    endif    $command_utils:suspend_if_needed(0);  endfor  if (anomaly && this:valid_space_object(anomaly))    anomaly:(verb)();    return 1;  else    pass(@args);  endifelse  pass(@args);endif"LMB #23230 01/22/2011";.@args #21733:"activate_msg oactivate_msg emerge_msg oemerge_msg" this none this@program #21733:activate_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/22/2011";.@args #19950:"bearing_report" this none this@program #19950:bearing_report{r, theta, phi} = this.bearing;r = tostr(r);theta = tostr(theta);phi = tostr(phi);return ((((theta + " mark ") + phi) + " at ") + r) + " light years";"LMB #23230 01/22/2011";.@args #21733:"@set-uni*verse @setuni*verse" any any any@program #21733:@set-universe"Usage:  @set-universe <destination universe>";" Sets the destination universe of this wormhole. That is, the universe a ship will enter upon emerging from the wormhole, if different from the current universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  return player:tell("Destination universe currently set to ", this.destination:title(), ".");endifif (typeof($code_utils:toobj(argstr)) != ERR)  universe = $code_utils:toobj(argstr);  if ($object_utils:isa(universe, #16043))    this.destination = universe;    player:tell("Destination universe set to ", universe:title(), ".");  else    player:tell(universe, " is not a known universe.");  endifelse  universe = $string_utils:match(argstr, $object_utils:descendants(#16043), "name");  if (universe == $ambiguous_match)*** More ***  17 lines left.  Do @more [rest|flush] for more.*** More ***  17 lines left.  Do @more [rest|flush] for more.*** More ***  36 lines left.  Do @more [rest|flush] for more.*** More ***  36 lines left.  Do @more [rest|flush] for more.@more r    player:tell("'", argstr, "' can refer to more than one universe (what are the odds of that?). Please be more specific.");  elseif (universe == $failed_match)    player:tell("'", argstr, "' is not the name of any known universe.");  else    this.destination = universe;    player:tell("Destination universe set to ", universe:title(), ".");  endifendif"LMB #23230 01/22/2011";.@args #19950:"heading_report" this none this@program #19950:heading_reportreturn this.heading ? this.heading:oname() | 0;"LMB #23230 01/22/2011";.@args #21733:"initialize" this none this@program #21733:initialize"LMB #23230 01/22/2011";."***finished***@args #19950:"exp" this none this@program #19950:expif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifitem = args[1];if (!(item in this.explored))  this.explored = {@this.explored, item};endif"LMB #23230 01/20/2011";.@args #19950:"midpoint" this none this@program #19950:midpoint"Returns the spherical coordinates of the midpoint of a line defined by the arguments, which should both also be sets of spherical coordinates.";{a, b} = args;universe = this.universe;{x1, y1, z1} = universe:convert(a);{x2, y2, z2} = universe:convert(b);midpoint = {0.5 * (x1 + x2), 0.5 * (y1 + y2), 0.5 * (z1 + z2)};return this.universe:aconvert(midpoint);"LMB #23230 01/21/2011";.@args #19950:"normalize" this none this@program #19950:normalize"Normalizes a vector given in two sets of Cartesian coordinates. That is, returns the corresponding (x, y, z) values for the unit vector of the given vector, which should be supplied as a start and end point, respectively.";{origin, dest} = args;{x1, y1, z1} = origin;{x2, y2, z2} = dest;ax = x2 - x1;ay = y2 - y1;az = z2 - z1;mag = sqrt(((ax ^ 2) + (ay ^ 2)) + (az ^ 2));`xv = ax / mag ! E_DIV => 0.0';`yv = ay / mag ! E_DIV => 0.0';`zv = az / mag ! E_DIV => 0.0';return {xv, yv, zv};"LMB #23230 01/21/2011";.@args #19950:"who_location_msg" this none this@program #19950:who_location_msgreturn ((pass(@args) + " [") + this:universe()) + "]";"LMB #23230 01/22/2011";.@args #19950:"title" this none this@program #19950:titleif (player.location != this)  return this:oname();else  return (this:oname() == this.name) ? pass(@args) | this:oname();endif"LMB #23230 01/22/2011";.i*** More ***  20 lines left.  Do @more [rest|flush] for more.@more r@args #19950:"find_heading" this none this@program #19950:find_headingif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifsearch = args[1];exp = this.explored;result = $string_utils:match(search, exp, "oname");return result;"LMB #23230 01/22/2011";."***finished***You are carrying:Tricorder (#22140)                 [MOOSpace] Generic Interstellar Cra[MOOSpace] Generic Space Object (# [MOOSpace] Generic Astrophysical An[MOOSpace] Generic Universe (#1604 [MOOSpace] Generic Wormhole (#21733[MOOSpace] Generic Heavenly Body ( @dump #22140;#22140.("key") = #23230;#22140.("aliases") = {"Tricorder", "Tri"};#22140.("object_size") = {710, 1295742401}"#22140.("original_owner") => E_PERM (Permission denied)"#22140.("days_left") => E_PERM (Permission denied);#22140.("creation_date") = 969428150"#22140.("queued_task_limit") => E_PERM (Permission denied)@args #22140:"shake" this none none@program #22140:shake#13676:shake();"LMB #23230 09/24/2000";."***finished***