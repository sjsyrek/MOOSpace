iYou are carrying:Tricorder (#22140)                 [MOOSpace] Generic Interstellar Cra[MOOSpace] Generic Space Object (# [MOOSpace] Generic Astrophysical An[MOOSpace] Generic Universe (#1604 [MOOSpace] Generic Wormhole (#21733[MOOSpace] Generic Heavenly Body ( @dump gso@chmod #7466."permitted" ;#7466.("permitted") = {}@chmod #7466."oname" r;#7466.("oname") = "[MOOSpace] Generic Space Object (outside)"@chmod #7466."odescription" r;#7466.("odescription") = {"This is the parent object for the MOOSpace system. Verbs and properties common to all space objects--such as spaceships, planets, and strange phenomena--reside here. You should not normally create children of this object, because they will not have any functionality, but you can create new classes of space objects from it if you desire. See the appropriate help for descendents of this object for more information:", "", "Generic Interstellar Craft: help #19950", "Generic Heavenly Body: help #7771", "Generic Cosmic Phenomenon: help #9602", "Generic Universe: help #16043", "", "MOOSpace Basic Information: help #13676", "Generic Space Object is a child of the Improved Generic-All-In-One Room: help #7424"}@chmod #7466."valid_space_object" r;#7466.("valid_space_object") = 0@chmod #7466."coordinates" ;#7466.("coordinates") = {0.0, 0.0, 0.0}@chmod #7466."universe" ;#7466.("universe") = 0@chmod #7466."cloaked" ;#7466.("cloaked") = 0;#7466.("w_time") = 975830400;#7466.("w_prog") = 6;#7466.("entrances") = {};#7466.("blessed_task") = 1815215361;#7466.("exits") = {};#7466.("blessed_object") = #119;#7466.("key") = 0;#7466.("aliases") = {"[MOOSpace] Generic Space Object", "gso"};#7466.("description") = "This is the inside of the MOOSpace Generic Space Object. What are you doing here? Go somewhere else and look at this object again for help.";#7466.("object_size") = {14391, 1295850919}"#7466.("original_owner") => E_PERM (Permission denied)"#7466.("days_left") => E_PERM (Permission denied);#7466.("creation_date") = 1290635626*** More ***  2 lines left.  Do @more [rest|flush] for more.@dump gu*** More ***  86 lines left.  Do @more [rest|flush] for more.*** More ***  126 lines left.  Do @more [rest|flush] for more.*** More ***  195 lines left.  Do @more [rest|flush] for more.*** More ***  205 lines left.  Do @more [rest|flush] for more.*** More ***  243 lines left.  Do @more [rest|flush] for more.*** More ***  255 lines left.  Do @more [rest|flush] for more.*** More ***  268 lines left.  Do @more [rest|flush] for more.*** More ***  293 lines left.  Do @more [rest|flush] for more.*** More ***  324 lines left.  Do @more [rest|flush] for more.*** More ***  332 lines left.  Do @more [rest|flush] for more.*** More ***  339 lines left.  Do @more [rest|flush] for more.*** More ***  375 lines left.  Do @more [rest|flush] for more.@dump gic*** More ***  465 lines left.  Do @more [rest|flush] for more.*** More ***  472 lines left.  Do @more [rest|flush] for more.*** More ***  482 lines left.  Do @more [rest|flush] for more.*** More ***  109 lines left.  Do @more [rest|flush] for more.*** More ***  142 lines left.  Do @more [rest|flush] for more.*** More ***  162 lines left.  Do @more [rest|flush] for more.*** More ***  180 lines left.  Do @more [rest|flush] for more.*** More ***  220 lines left.  Do @more [rest|flush] for more.*** More ***  247 lines left.  Do @more [rest|flush] for more.*** More ***  289 lines left.  Do @more [rest|flush] for more.@dump ghb*** More ***  366 lines left.  Do @more [rest|flush] for more.*** More ***  403 lines left.  Do @more [rest|flush] for more.*** More ***  406 lines left.  Do @more [rest|flush] for more.*** More ***  429 lines left.  Do @more [rest|flush] for more.*** More ***  457 lines left.  Do @more [rest|flush] for more.*** More ***  105 lines left.  Do @more [rest|flush] for more.*** More ***  105 lines left.  Do @more [rest|flush] for more.*** More ***  181 lines left.  Do @more [rest|flush] for more.*** More ***  202 lines left.  Do @more [rest|flush] for more.*** More ***  202 lines left.  Do @more [rest|flush] for more.*** More ***  303 lines left.  Do @more [rest|flush] for more.@dump gaa*** More ***  310 lines left.  Do @more [rest|flush] for more.*** More ***  352 lines left.  Do @more [rest|flush] for more.*** More ***  352 lines left.  Do @more [rest|flush] for more.*** More ***  371 lines left.  Do @more [rest|flush] for more.*** More ***  381 lines left.  Do @more [rest|flush] for more.*** More ***  404 lines left.  Do @more [rest|flush] for more.*** More ***  453 lines left.  Do @more [rest|flush] for more.*** More ***  469 lines left.  Do @more [rest|flush] for more.*** More ***  152 lines left.  Do @more [rest|flush] for more.*** More ***  169 lines left.  Do @more [rest|flush] for more.*** More ***  178 lines left.  Do @more [rest|flush] for more.*** More ***  186 lines left.  Do @more [rest|flush] for more.*** More ***  202 lines left.  Do @more [rest|flush] for more.*** More ***  271 lines left.  Do @more [rest|flush] for more.@dump gw*** More ***  302 lines left.  Do @more [rest|flush] for more.*** More ***  321 lines left.  Do @more [rest|flush] for more.*** More ***  353 lines left.  Do @more [rest|flush] for more.*** More ***  393 lines left.  Do @more [rest|flush] for more.*** More ***  415 lines left.  Do @more [rest|flush] for more.*** More ***  448 lines left.  Do @more [rest|flush] for more.*** More ***  455 lines left.  Do @more [rest|flush] for more.*** More ***  481 lines left.  Do @more [rest|flush] for more.*** More ***  481 lines left.  Do @more [rest|flush] for more.*** More ***  115 lines left.  Do @more [rest|flush] for more.*** More ***  141 lines left.  Do @more [rest|flush] for more.*** More ***  169 lines left.  Do @more [rest|flush] for more.*** More ***  175 lines left.  Do @more [rest|flush] for more.*** More ***  227 lines left.  Do @more [rest|flush] for more.*** More ***  244 lines left.  Do @more [rest|flush] for more.*** More ***  333 lines left.  Do @more [rest|flush] for more.*** More ***  333 lines left.  Do @more [rest|flush] for more.*** More ***  434 lines left.  Do @more [rest|flush] for more.*** More ***  434 lines left.  Do @more [rest|flush] for more.*** More ***  114 lines left.  Do @more [rest|flush] for more.*** More ***  114 lines left.  Do @more [rest|flush] for more.*** More ***  131 lines left.  Do @more [rest|flush] for more.@more r*** More ***  131 lines left.  Do @more [rest|flush] for more.*** buffer overflow, lines flushed ***      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelseif (ph = this:match_phenomenon(argstr))  if ($list_utils:flatten(this.pdetails[ph[1]]) == {})    return player:tell("There are no details defined on ", this.pnames[ph[1]], ".");  endif  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details defined on ", this.pnames[ph[1]], "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for ph_index in (ph)      if (this.pdetails[ph_index])        details = length(this.pdetails[ph_index][1]);        for d in [1..details]          player:tell(this.pdetails[ph_index][1][d], " cleared from ", this.pnames[ph_index], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[ph_index] = {};        player:tell("All details cleared from ", this.pnames[ph_index], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelse  player:tell("There is no phenomenon called ", argstr, " defined on ", this:title(), ".");endif"LMB #23230 01/18/2011";.@args #19950:"engines" this none this@program #19950:enginesif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif"This function moves the ship using vector math.";"while (this.universe:distance(this.coordinates, this.bearing) > (this.speed))";"  speed = this.speed;";"  midpoint = this:midpoint(this.coordinates, this.bearing);";"  while (d = this.universe:distance(this.coordinates, midpoint) > (speed))";"    midpoint = this:midpoint(this.coordinates, midpoint);";"  endwhile";"  this.coordinates = midpoint;";"endwhile";" <----- OLD CODE ABOVE, NEW CODE BELOW ----->";origin = this.coordinates;chars = {".", "@", "*", "+", "o", ".", "@", "*", "+", " "};count = 0;while (((d = this.universe:distance(this.coordinates, this.bearing)) > 0.0) && this.engines)  count = count + 1;  stars = {};  for s in [1..79]    mod = random(50);    stars = (mod <= 10) ? {@stars, chars[mod]} | {@stars, " "};  endfor  speed = this.speed;  {x1, y1, z1} = this.universe:convert(this.coordinates);  {x2, y2, z2} = this.universe:convert(this.bearing);  {xv, yv, zv} = this:normalize({x1, y1, z1}, {x2, y2, z2});  x = x1 + (speed * xv);  y = y1 + (speed * yv);  z = z1 + (speed * zv);  old_range = this.coordinates;  this.coordinates = this.universe:aconvert({x, y, z});  this.coordinates[2] = this.bearing[2];  this.coordinates[3] = this.bearing[3];  "Do something here.";  this:range_update(old_range);  suspend(1);  if (d <= speed)    suspend(1);    this.coordinates = this.bearing;  endif  if ($command_utils:running_out_of_time())    this:announce_all(this:title(), " is passing through an unstable area of space and needs a moment to stabilize.");    suspend(60);    this:announce_all(this:title(), " has successfully stabilized.");  endif  if ((count == 10) && $set_utils:intersection(this.contents, connected_players()))    this:announce_all($string_utils:center($string_utils:from_list(stars), 79));    count = 0;  endifendwhilereturn ((this.coordinates == origin) || (this.universe:distance(this.coordinates, origin) == 0.0)) ? 0 | 1;"LMB #23230 01/23/2011";.@args #16043:"phenomenon" this none this@program #16043:phenomenonindex = args[1];name = this.pnames[index];data = this.pvalues[index][2];shape_index = this.pvalues[index][3];shape = this.p_shapes[shape_index];string = "";if (shape == "sphere")  string = ((name + " has a radius of ") + tostr(data[1])) + ".";elseif (shape == "ellipsoid")  string = ((name + " has three semiaxes of lengths ") + $string_utils:english_list(data)) + ". ";elseif (shape == "torus")  string = ((((name + " has a radius of ") + tostr(data[1])) + " and its tube has a radius of ") + tostr(data[2])) + ".";elseif (shape == "elliptical_torus")  string = ((((((name + " has two semiaxes of lengths ") + tostr(data[1])) + " and ") + tostr(data[2])) + " and a radial semiaxis of ") + tostr(data[3])) + ".";endifreturn string;"LMB #23230 01/19/2011";.@args #19950:"commander_msg ocommander_msg launch_start_msg olaunch_start_msg launch_start_outside_msg launch_end_msg olaunch_end_msg board_msg oboard_msg oboard_depart_msg disembark_msg odisembark_msg odisembark_arrive_msg land_start_msg oland_start_msg land_end_msg oland_end_msg land_end_outside_msg scan_msg oscan_msg disengage_msg odisengage_msg engage_origin_msg oengage_origin_msg engage_arrive_msg oengage_arrive_msg hail_origin_msg ohail_origin_msg hail_receive_msg" this none this@program #19950:commander_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/09/2011";.@args #16043:"acceptable" this none this@program #16043:acceptablereturn ((this:perm_check(@args) || (caller_perms() == this.owner)) || (caller_perms() == #23230)) && pass(@args);"LMB #23230 01/23/2011";."***finished***@args #19950:"here_huh" this none this@program #19950:here_huh"Look for something to do on an astrophysical anomaly.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endif{verb, ?target = ""} = args;if (target && this:valid_space_object())  range = this.in_range[1];  anomaly = 0;  for o in (range)    if (($object_utils:isa(o, #9602) && match(o:title(), target)) && $object_utils:match_verb(o, verb))      anomaly = o;      verb = $object_utils:match_verb(o, verb)[2];    endif    $command_utils:suspend_if_needed(0);  endfor  if (anomaly && this:valid_space_object(anomaly))    anomaly:(verb)();    return 1;  else    pass(@args);  endifelse  pass(@args);endif"LMB #23230 01/22/2011";.@args #19950:"bearing_report" this none this@program #19950:bearing_report{r, theta, phi} = this.bearing;*** More ***  7 lines left.  Do @more [rest|flush] for more.@more rr = tostr(r);theta = tostr(theta);phi = tostr(phi);return ((((theta + " mark ") + phi) + " at ") + r) + " light years";"LMB #23230 01/22/2011";.@args #19950:"heading_report" this none this@program #19950:heading_reportreturn this.heading ? this.heading:oname() | 0;"LMB #23230 01/22/2011";.@args #19950:"exp" this none this@program #19950:expif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifitem = args[1];if (!(item in this.explored))  this.explored = {@this.explored, item};endif"LMB #23230 01/20/2011";.@args #19950:"midpoint" this none this@program #19950:midpoint"Returns the spherical coordinates of the midpoint of a line defined by the arguments, which should both also be sets of spherical coordinates.";{a, b} = args;universe = this.universe;{x1, y1, z1} = universe:convert(a);{x2, y2, z2} = universe:convert(b);midpoint = {0.5 * (x1 + x2), 0.5 * (y1 + y2), 0.5 * (z1 + z2)};return this.universe:aconvert(midpoint);"LMB #23230 01/21/2011";.@args #19950:"normalize" this none this@program #19950:normalize"Normalizes a vector given in two sets of Cartesian coordinates. That is, returns the corresponding (x, y, z) values for the unit vector of the given vector, which should be supplied as a start and end point, respectively.";{origin, dest} = args;{x1, y1, z1} = origin;{x2, y2, z2} = dest;ax = x2 - x1;ay = y2 - y1;az = z2 - z1;mag = sqrt(((ax ^ 2) + (ay ^ 2)) + (az ^ 2));`xv = ax / mag ! E_DIV => 0.0';`yv = ay / mag ! E_DIV => 0.0';`zv = az / mag ! E_DIV => 0.0';return {xv, yv, zv};"LMB #23230 01/21/2011";.@args #19950:"who_location_msg" this none this@program #19950:who_location_msgreturn ((pass(@args) + " [") + this:universe()) + "]";"LMB #23230 01/22/2011";.@args #19950:"title" this none this@program #19950:titleif (player.location != this)  return this:oname();else  return (this:oname() == this.name) ? pass(@args) | this:oname();endif"LMB #23230 01/22/2011";.@more r@args #19950:"find_heading" this none this@program #19950:find_headingif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifsearch = args[1];exp = this.explored;result = $string_utils:match(search, exp, "oname");return result;"LMB #23230 01/22/2011";.@args #19950:"loc*ation" none none none@program #19950:locationplayer:tell(this:title(), " is in ", this:universe(), " ", this:location_report());"LMB #23230 01/23/2011";."***finished***iYou are carrying:Tricorder (#22140)                 [MOOSpace] Generic Interstellar Cra[MOOSpace] Generic Space Object (# [MOOSpace] Generic Astrophysical An[MOOSpace] Generic Universe (#1604 [MOOSpace] Generic Wormhole (#21733[MOOSpace] Generic Heavenly Body ( @dump gso@chmod #7466."permitted" ;#7466.("permitted") = {}@chmod #7466."oname" r;#7466.("oname") = "[MOOSpace] Generic Space Object (outside)"@chmod #7466."odescription" r;#7466.("odescription") = {"This is the parent object for the MOOSpace system. Verbs and properties common to all space objects--such as spaceships, planets, and strange phenomena--reside here. You should not normally create children of this object, because they will not have any functionality, but you can create new classes of space objects from it if you desire. See the appropriate help for descendents of this object for more information:", "", "Generic Interstellar Craft: help #19950", "Generic Heavenly Body: help #7771", "Generic Cosmic Phenomenon: help #9602", "Generic Universe: help #16043", "", "MOOSpace Basic Information: help #13676", "Generic Space Object is a child of the Improved Generic-All-In-One Room: help #7424"}@chmod #7466."valid_space_object" r;#7466.("valid_space_object") = 0@chmod #7466."coordinates" ;#7466.("coordinates") = {0.0, 0.0, 0.0}@chmod #7466."universe" ;#7466.("universe") = 0@chmod #7466."cloaked" ;#7466.("cloaked") = 0;#7466.("w_time") = 975830400;#7466.("w_prog") = 6;#7466.("entrances") = {};#7466.("blessed_task") = 1815215361;#7466.("exits") = {};#7466.("blessed_object") = #119;#7466.("key") = 0;#7466.("aliases") = {"[MOOSpace] Generic Space Object", "gso"};#7466.("description") = "This is the inside of the MOOSpace Generic Space Object. What are you doing here? Go somewhere else and look at this object again for help.";#7466.("object_size") = {14391, 1295850919}"#7466.("original_owner") => E_PERM (Permission denied)"#7466.("days_left") => E_PERM (Permission denied);#7466.("creation_date") = 1290635626*** More ***  2 lines left.  Do @more [rest|flush] for more.@more r"#7466.("queued_task_limit") => E_PERM (Permission denied)@args #7466:"perm_check" this none this@program #7466:perm_check"Takes a single object as an argument, usually the value of caller if passed from the command line and caller_perms() otherwise. Returns true if the object (typically a player) is this, this.owner, listed in this.permitted, or a wizard. Returns false otherwise or if the argument list is the wrong length. This is a permissions check meant to prevent verb spoofing. Every command verb defined on MOOSpace objects should use it. Since it's so important, perm_check() does considerable maintenance on this.permitted whenever it's called.";{?TestCase = 0, @rest} = args;if (!$perm_utils:controls(caller_perms(), this))  return E_PERM;elseif ((typeof(TestCase) != OBJ) || rest)  return E_ARGS;elseif (!$object_utils:has_property(this, "permitted"))  player:tell("** ERROR: The .permitted property on ", this.name, " is either missing or broken.");  return $perm_utils:controls(caller_perms(), this);elseif (typeof(this.permitted) != LIST)  this.permitted = {};endiftrusted_list = {#23230, this};permitted_list = this.permitted;"The for loop below makes sure the objects in this.permitted are valid (i.e. they exist and haven't been recycled) and cleans it up if necessary.";for trusted_object in (permitted_list = $list_utils:remove_duplicates($list_utils:flatten(permitted_list)))  $command_utils:suspend_if_needed(0);  if ((typeof(trusted_object) == OBJ) && $recycler:valid(trusted_object))    trusted_list = {@trusted_list, trusted_object};  else    permitted_list = setremove(permitted_list, trusted_object);  endifendforthis.permitted = permitted_list;return (TestCase in trusted_list) || $perm_utils:controls(TestCase, this);"LMB #23230 01/23/2011";.@args #7466:"look_self" this none this@program #7466:look_self"Displays different names and descriptions depending on the location of the calling player--the 'o' name and description if the player is outside of the object, and the regular ones otherwise.";if ($object_utils:contains(this, player))  pass(@args);else  player:tell(this:oname());  player:tell_lines(this:odescription());endif"LMB #23230 12/08/2010";.@args #7466:"oname odescription noperms_msg" this none this@program #7466:oname"Verb -> property matching for messages defined on this object. You can make your own versions of these verbs if you want to implement fancy formatting.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 12/08/2010";.@args #7466:"@permit @trust" any any any@program #7466:@permit"Usage:  @permit <any player> | @permit -<any player>";"  Commissions a player other than the owner to operate or modify this space object. Only the owner, however, can use this command. Use a minus sign '-' in front of the player's name to decommission that player";if (!$perm_utils:controls(caller, this))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  permitted_list = $list_utils:remove_duplicates({this.owner, @this.permitted});  player:tell($string_utils:title_list(permitted_list), (permitted_list == {this.owner}) ? " is " | " are ", $string_utils:pronoun_sub("permitted to operate and modify %t."));@more relseif (dobjstr[1] == "-")  match = $string_utils:match(dobjstr[2..$], {this.owner, @this.permitted}, "aliases");  if ((match == this.owner) && (this.permitted == {}))    player:tell("You cannot decommission yourself!");  elseif (match in this.permitted)    this.permitted = setremove(this.permitted, match);    player:tell(match:title(), $string_utils:pronoun_sub(" is no longer commissioned to operate or modify %t."));  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  else    player:tell(dobjstr, $string_utils:pronoun_sub(" is not the name of any player currently commissioned to operate and modify %t."));  endifelse  match = $string_utils:match_player(tostr(dobjstr));  if (match == $failed_match)    player:tell("No player called ", dobjstr, " can be found. Try using the player's object number instead.");  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  elseif (match in this.permitted)    player:tell(match:title(), $string_utils:pronoun_sub(" is already permitted to operate and modify %t."));  else    this.permitted = {@this.permitted, match};    player:tell(match:title(), $string_utils:pronoun_sub(" is now commissioned to operate and modify %t."));  endifendif"LMB #23230 01/23/2011";.@args #7466:"moveto" this none this@program #7466:movetoif (!this:perm_check(caller))  player:tell("Gravity discourages you from even attempting that.");  return;endifreturn pass(@args);"LMB #23230 01/09/2011";.@args #7466:"valid_space_object" this none this@program #7466:valid_space_object"Returns 1 if this object, or the dobj if provided, has been properly initialized to work with MOOSpace and 0 otherwise. You can create your own version of this verb if you want more specialized space objects to satisfy additional conditions.";if (args)  dobj = args[1];  return ($object_utils:isa(dobj, #7466) && dobj.valid_space_object) ? 1 | 0;endifreturn ($object_utils:isa(this, #7466) && this.valid_space_object) ? 1 | 0;"LMB #23230 01/15/2011";.@args #7466:"universe universe_desc" this none this@program #7466:universe"Returns either the name of this universe or the name of the phenomenon in which the caller is located.";if ((!this:perm_check(caller)) && (!this:perm_check(caller_perms())))  player:tell(this:noperms_msg());  return E_PERM;endifcoordinates = this.coordinates;pinfo = (verb == "universe") ? this.universe:title() | this.universe:description();called_verb = verb;for p in (this.universe.pvalues)  shape = p[3];  verb_name = this.universe.p_shapes[shape] + "_contains";  verb = $object_utils:has_callable_verb(this.universe, verb_name) ? verb_name | "sphere_contains";  data = p[2];  if (this.universe:(verb)(data, coordinates))    index = p in this.universe.pvalues;    pinfo = (called_verb == "universe") ? this.universe.pnames[index] | this.universe.pdescs[index];  endif  $command_utils:suspend_if_needed(0);endforreturn pinfo;"LMB #23230 01/23/2011";.@args #7466:"initialize" this none this@program #7466:initialize"A space object must be initialized before it can interact with the MOOSpace system. Initialization sets a few necessary default values based on user input. To initialize a spaceship, visit the San Francisco Shipyards adjacent to Starfleet Headquarters. To initialize a heavenly body, you must find the planet Magrathea. If you want to create anomalies and other phenomena, you'll have to do a bit more exploring on your own.";"LMB #23230 01/19/2011";.@args #7466:"@cloak" any any any@program #7466:@cloak"Usage:  @cloak <on> or <off> | @cloak";"  Cloaks or uncloaks this space object. A cloaked object will be invisible to other ships when they scan. Without 'on' or 'off' as an argument, reports the current cloak status.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  status = (this.cloaked == 1) ? " is currently " | " is not currently ";  player:tell(this:title(), status, "cloaked.");elseif (argstr == "on")  if (this.cloaked == 1)    player:tell(this:title(), " is already cloaked.");  else    this.cloaked = 1;    player:tell(this:title(), " is now cloaked.");    this:announce(player:title(), " has activated the cloaking device!");    this:range_update(this.in_range);  endifelseif (argstr == "off")  if (this.cloaked == 0)    player:tell(this:title(), " is not currently cloaked.");  else@more    this.cloaked = 0;    player:tell(this:title(), " is no longer cloaked.");    this:range_update(this.in_range);    this:announce(player:title(), " has deactivated the cloaking device.");  endifelse  player:tell("Usage:  @cloak <on> or <off> | @cloak");endif"LMB #23230 01/22/2011";.@args #7466:"location_report" this none this@program #7466:location_report{r, theta, phi} = this.coordinates;r = tostr(r);theta = tostr(theta);phi = tostr(phi);return ((((("(" + theta) + " mark ") + phi) + " at ") + r) + " light years)";"LMB #23230 01/22/2011";.@args #7466:"@oname" any none none@program #7466:@oname"Usage:  @oname <name> | @oname";"  Change or show the exterior display name of this space object.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  player:tell("Exterior display name of ", this.name, " (", this, ") is ", this:oname(), ".");else  name = argstr;  if (length(name) > 40)*** More ***  35 lines left.  Do @more [rest|flush] for more.@more r    return player:tell(tostr("That name is too long. The maximum number of characters allowed in a name is ", $login.max_player_name, "."));  endif  this.oname = name;  player:tell("Exterior display name of ", this.name, " (", this, ") changed to ", name, ".");endif"LMB #23230 01/22/2011";.@args #7466:"@odesc*ription" any any any@program #7466:@odescription"Usage:  @odescription <description> | @odescription";"  Change or show the exterior display description of this space object. Due to permissions checking with the note editor, I cannot make this any more robust. Sorry.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  player:tell("Exterior display description of ", this.name, " (", this, ") is:");  player:tell_lines(this:odescription());  if ($string_utils:find_prefix($command_utils:read(player:tell("Do you want to edit this description?")), {"yes", "1"}))    desc = $command_utils:read_lines();    this.odescription = desc;    player:tell("Exterior display description of ", this.name, " (", this, ") changed.");  else    player:tell("Exterior display description unchanged.");  endifelse  desc = argstr;  this.odescription = desc;  player:tell("Exterior display description of ", this.name, " (", this, ") changed.");endif"LMB #23230 01/22/2011";."***finished***@dump ghb@chmod #7771."trusted_ships" ;#7771.("trusted_ships") = {}@chmod #7771."not_trusted_ship_msg" r;#7771.("not_trusted_ship_msg") = "Permission denied. Your ship is not trusted by %t.";#7771.("oname") = "[MOOSpace] Generic Heavenly Body";#7771.("odescription") = {"This is the parent of all heavenly bodies in the MOOSpace system. To create one for yourself, seek out the planet-builders of Magrathea."};#7771.("w_time") = 948960000;#7771.("w_prog") = 1;#7771.("entrances") = {};#7771.("blessed_task") = 1815215361;#7771.("exits") = {};#7771.("blessed_object") = #119;#7771.("key") = 0;#7771.("aliases") = {"[MOOSpace] Generic Heavenly Body", "ghb"};#7771.("description") = "This is the parent of all heavenly bodies in the MOOSpace system. To create one for yourself, seek out the planet-builders of Magrathea.";#7771.("object_size") = {6873, 1295850919}"#7771.("original_owner") => E_PERM (Permission denied)"#7771.("days_left") => E_PERM (Permission denied);#7771.("creation_date") = 969427645"#7771.("queued_task_limit") => E_PERM (Permission denied)@args #7771:"@add-sh*ip @addsh*ip @remove-sh*ip @removesh*ip @rm-sh*ip @rmsh*ip" any none none@program #7771:@add-ship"Usage:  @add-ship | @remove-ship <ship name or object number>";"  Grants or rescinds landing permission to a spaceship, which must be a descendant of Generic Interstellar Craft. If no ships are specifically given landing permission, then all ships have permission. If any ships are given permission with this command, only those ships will then have landing permission.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())*** More ***  38 lines left.  Do @more [rest|flush] for more.@more r  return player:tell(this:title(), " must be initialized before it can be modified. Type 'help #7466:initialize' for details.");endifif (!dobjstr)  return player:tell("Usage: @", (verb[2] == "r") ? "remove-ship" | "add-ship", " <ship name or object number>");endiftarget = (toobj(dobjstr) != #0) ? toobj(dobjstr) | dobjstr;if (verb[2] == "r")  if (typeof(target) == OBJ)    result = (target in this:trusted_ships()) ? target | $failed_match;  elseif (typeof(target) == STR)    result = $string_utils:match(target, this:trusted_ships(), "name");  endifelseif (verb[2] == "a")  if (typeof(target) == OBJ)    result = $object_utils:isa(target, #19950) ? target | $failed_match;  elseif (typeof(target) == STR)    result = $string_utils:match(target, $object_utils:descendants(#19950), "name");  endifendifif (result in this:trusted_ships())  if (verb[2] == "r")    this.trusted_ships = setremove(this.trusted_ships, result);    player:tell(result:title(), " is no longer permitted to ", $object_utils:isa(this, #19950) ? "dock at " | "land on ", this:title(), ".");    return;  endif  player:tell(result:title(), " has already been granted landing permission for ", this:title(), ".");elseif ((result == $failed_match) || (!result:valid_space_object()))  player:tell(dobjstr, " either doesn't exist or is not a valid ship.");elseif (result == $ambiguous_match)  player:tell(dobjstr, " can refer to more than one ship. Be more specific or use the ship's object number instead.");elseif (verb[2] == "a")  this.trusted_ships = {@this.trusted_ships, result};  land_or_dock = $object_utils:isa(this, #19950) ? "dock at" | "land on";  player:tell(result:title(), " is now permitted to ", land_or_dock, " ", this:title(), ".");endif"LMB #23230 01/19/2011";.@args #7771:"@ships" none none none@program #7771:@ships"Usage:  @ships";"  Displays the names of the ships currently permitted to land on this ship or heavenly body. If no ships are specified, then all ships are permitted to land.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be used. Type 'help #7466:initialize' for details.");endifships = this.trusted_ships;if (ships)  player:tell($string_utils:title_list(ships), (length(ships) == 1) ? " is " | " are ", "permitted to ", $object_utils:isa(this, #19950) ? "dock at " | "land on ", this:title(), ".");else  player:tell("Any ship may ", $object_utils:isa(this, #19950) ? "dock at " | "land on ", this:title(), ".");endif"LMB #23230 01/19/2011";.@args #7771:"not_trusted_ship_msg" this none this@program #7771:not_trusted_ship_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/19/2011";.@args #7771:"trusted_ships" this none this@program #7771:trusted_ships"Returns this.trusted_ships after cleaning it up.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endiftrusted_list = {};trusted_ships = this.trusted_ships;for s in (trusted_ships)  if ((((typeof(s) == OBJ) && $recycler:valid(s)) && $object_utils:isa(s, #19950)) && s:valid_space_object())    trusted_list = {@trusted_list, s};  else    trusted_ships = setremove(trusted_ships, s);  endif  $command_utils:suspend_if_needed(0);endforthis.trusted_ships = trusted_ships;return trusted_list;"LMB #23230 01/19/2011";."***finished***@dump gaa;#9602.("oname") = "[MOOSpace] Generic Astrophysical Anomaly";#9602.("odescription") = {"This is the parent of all astrophysical anomalies in the MOOSpace system. To create one for yourself, you'll have to do lots of exploring."};#9602.("w_time") = 948700800;#9602.("w_prog") = 4;#9602.("entrances") = {};#9602.("blessed_task") = 1815215361;#9602.("exits") = {};#9602.("blessed_object") = #119;#9602.("key") = 0*** More ***  9 lines left.  Do @more [rest|flush] for more.@more r;#9602.("aliases") = {"[MOOSpace] Generic Astrophysical Anomaly", "gaa"};#9602.("description") = "This is the parent of all astrophysical anomalies in the MOOSpace system. To create one for yourself, you'll have to do lots of exploring.";#9602.("object_size") = {3231, 1295850919}"#9602.("original_owner") => E_PERM (Permission denied)"#9602.("days_left") => E_PERM (Permission denied);#9602.("creation_date") = 969427652"#9602.("queued_task_limit") => E_PERM (Permission denied)@args #9602:"app*roach" this none none@program #9602:approach"Usage:  approach <this>";"  Activates this astrophysical anomaly. The results are unpredictable.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endifif (this:valid_space_object())  if (!this:activate())    player:tell("Nothing happens.");  endifendif"LMB #23230 01/23/2011";.@args #9602:"activate" this none this@program #9602:activate"You must create your own version of this verb if you want this anomaly to do something.";return 0;"LMB #23230 01/22/2011";."***finished***@dump gw@chmod #21733."activate_msg" r;#21733.("activate_msg") = "You command %l to cross the event horizon of %t!"@chmod #21733."oactivate_msg" r;#21733.("oactivate_msg") = "%n commands %l to cross the event horizon of %t!"@chmod #21733."destination" ;#21733.("destination") = #16043@chmod #21733."mouth" ;#21733.("mouth") = {0.0, 0.0, 0.0}@chmod #21733."emerge_msg" r;#21733.("emerge_msg") = "%l emerges from %t into"@chmod #21733."oemerge_msg" r;#21733.("oemerge_msg") = "%l emerges from %t into";#21733.("oname") = "[MOOSpace] Generic Wormhole";#21733.("odescription") = {"This is a parent object for wormholes in the MOOSpace system. A wormhole can lead to another part of its universe or to an entirely different universe."};#21733.("w_time") = 952848000;#21733.("w_prog") = 4;#21733.("entrances") = {};#21733.("blessed_task") = 1815215361;#21733.("exits") = {};#21733.("blessed_object") = #119;#21733.("key") = 0;#21733.("aliases") = {"[MOOSpace] Generic Wormhole", "gw"};#21733.("description") = "This is a parent object for wormholes in the MOOSpace system. A wormhole can lead to another part of its universe or to an entirely different universe."*** More ***  6 lines left.  Do @more [rest|flush] for more.@More r;#21733.("object_size") = {5961, 1295850919}"#21733.("original_owner") => E_PERM (Permission denied)"#21733.("days_left") => E_PERM (Permission denied);#21733.("creation_date") = 970429962"#21733.("queued_task_limit") => E_PERM (Permission denied)@args #21733:"activate" this none this@program #21733:activateif (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endifship = player.location;player:tell(this:activate_msg());ship:announce(this:oactivate_msg());if ($object_utils:isa(ship, #19950))  ship:moveto(this);  if (ship.location == this)    ship.in_range = this;    ship:range_update(this.in_range);    suspend(5);    ship:announce_all(this:description());    suspend(5);    if ($object_utils:isa(this.destination, #16043) && (typeof(this.mouth) == LIST))      ship:moveto(this.destination);      if (ship.location == this.destination)        ship.universe = this.destination;        ship.coordinates = this.mouth;        player:tell(((this:emerge_msg() + " ") + ship:universe()) + ".");        ship:announce(((this:oemerge_msg() + " ") + ship:universe()) + ".");        ship:scan();      else        ship:moveto(this.universe);        player:tell(((this:emerge_msg() + " ") + ship:universe()) + ".");        ship:announce(((this:oemerge_msg() + " ") + ship:universe()) + ".");        ship:scan();        ship:range_update(ship.in_range);      endif      return 1;    endif  endifendifreturn 0;"LMB #23230 01/22/2011";.@args #21733:"activate_msg oactivate_msg emerge_msg oemerge_msg" this none this@program #21733:activate_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/22/2011";.@args #21733:"@set-uni*verse @setuni*verse" any any any@program #21733:@set-universe"Usage:  @set-universe <destination universe>";" Sets the destination universe of this wormhole. That is, the universe a ship will enter upon emerging from the wormhole, if different from the current universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  return player:tell("Destination universe currently set to ", this.destination:title(), ".");endifif (typeof($code_utils:toobj(argstr)) != ERR)  universe = $code_utils:toobj(argstr);  if ($object_utils:isa(universe, #16043))    this.destination = universe;    player:tell("Destination universe set to ", universe:title(), ".");  else    player:tell(universe, " is not a known universe.");  endifelse  universe = $string_utils:match(argstr, $object_utils:descendants(#16043), "name");  if (universe == $ambiguous_match)    player:tell("'", argstr, "' can refer to more than one universe (what are the odds of that?). Please be more specific.");  elseif (universe == $failed_match)    player:tell("'", argstr, "' is not the name of any known universe.");@dump gic*** More ***  104 lines left.  Do @more [rest|flush] for more.@more r  else    this.destination = universe;    player:tell("Destination universe set to ", universe:title(), ".");  endifendif"LMB #23230 01/22/2011";.@args #21733:"initialize" this none this@program #21733:initialize"LMB #23230 01/22/2011";."***finished***@chmod #19950."heading" ;#19950.("heading") = 0@chmod #19950."bearing" ;#19950.("bearing") = {0.0, 0.0, 0.0}@chmod #19950."speed" ;#19950.("speed") = 1@chmod #19950."in_range" ;#19950.("in_range") = {{}, {}, {}, {}}@chmod #19950."engage_origin_msg" r;#19950.("engage_origin_msg") = "You say, \"Engage!\" and %t powers up its engines."@chmod #19950."oengage_origin_msg" r;#19950.("oengage_origin_msg") = "%n says, \"Engage!\" and %t powers up its engines."@chmod #19950."engage_arrive_msg" r;#19950.("engage_arrive_msg") = "You have brought %t safely to its destination."@chmod #19950."oengage_arrive_msg" r;#19950.("oengage_arrive_msg") = "%t arrives safely at its destination."@chmod #19950."hail_origin_msg" r;#19950.("hail_origin_msg") = "You hail %d with: "@chmod #19950."ohail_origin_msg" r;#19950.("ohail_origin_msg") = "%n hails %d with: "@chmod #19950."hail_receive_msg" r;#19950.("hail_receive_msg") = "%n hails from %t: "@chmod #19950."commander_msg" r;#19950.("commander_msg") = "The crew stands at attention as you enter the bridge."@chmod #19950."ocommander_msg" r;#19950.("ocommander_msg") = "The crew stands at attention as %n enters the bridge."@chmod #19950."launch_start_msg" r;#19950.("launch_start_msg") = "You launch %t into space."@chmod #19950."olaunch_start_msg" r;#19950.("olaunch_start_msg") = "%n launches %t into space."@chmod #19950."launch_start_outside_msg" r;#19950.("launch_start_outside_msg") = "%t rises into the air and blasts off into space."@chmod #19950."launch_end_msg" r;#19950.("launch_end_msg") = "%t arrives safely in"@chmod #19950."olaunch_end_msg" r;#19950.("olaunch_end_msg") = "%n has successfully launched %t into"@chmod #19950."board_msg" r;#19950.("board_msg") = "You board %t."@chmod #19950."oboard_msg" r;#19950.("oboard_msg") = "%n boards %t."@chmod #19950."oboard_depart_msg" r;#19950.("oboard_depart_msg") = "%n has boarded %t."@chmod #19950."disembark_msg" r;#19950.("disembark_msg") = "You have disembarked from %t."@chmod #19950."odisembark_msg" r;#19950.("odisembark_msg") = "%n has disembarked from %t for %l."@chmod #19950."odisembark_arrive_msg" r;#19950.("odisembark_arrive_msg") = "%n disembarks from %t."@chmod #19950."land_start_msg" r;#19950.("land_start_msg") = "You lower the landing gear and prepare to land %t on"@chmod #19950."oland_start_msg" r;#19950.("oland_start_msg") = "%n lowers the landing gear and prepares to land %t on"@chmod #19950."land_end_msg" r;#19950.("land_end_msg") = "You bring %t in for a smooth landing on"@chmod #19950."oland_end_msg" r;#19950.("oland_end_msg") = "%n brings %t in for a smooth landing on"@chmod #19950."land_end_outside_msg" r;#19950.("land_end_outside_msg") = "%t soars in from outer space and lands gracefully nearby."@chmod #19950."engines" ;#19950.("engines") = 0@chmod #19950."explored" ;#19950.("explored") = {}@chmod #19950."scan_msg" r;#19950.("scan_msg") = "A beam of light from %t scans you."@chmod #19950."oscan_msg" r;#19950.("oscan_msg") = "A beam of light from %t scans"@chmod #19950."disengage_msg" r;#19950.("disengage_msg") = "You disengage the engines and bring %t to a full stop."@chmod #19950."odisengage_msg" r;#19950.("odisengage_msg") = "%n disengages the engines and brings %t to a full stop.";#19950.("oname") = "[MOOSpace] Generic Interstellar Craft";#19950.("odescription") = {"This is the parent of all spaceships in the MOOSpace system. To create one for yourself, visit the San Francisco Shipyards adjacent to Starfleet Headquarters."};#19950.("noperms_msg") = "You are not authorized to operate %t.";#19950.("w_time") = 950428800;#19950.("w_prog") = 6;#19950.("entrances") = {};#19950.("blessed_task") = 1815215361;#19950.("exits") = {};#19950.("blessed_object") = #119;#19950.("key") = 0;#19950.("aliases") = {"[MOOSpace] Generic Interstellar Craft", "gic"};#19950.("description") = "This is the parent of all spaceships in the MOOSpace system. To create one for yourself, visit the San Francisco Shipyards adjacent to Starfleet Headquarters.";#19950.("object_size") = {37989, 1295850919}"#19950.("original_owner") => E_PERM (Permission denied)"#19950.("days_left") => E_PERM (Permission denied);#19950.("creation_date") = 969427497"#19950.("queued_task_limit") => E_PERM (Permission denied)@args #19950:"laun*ch" none none none@program #19950:launch"Usage:  launch";"  Launches this ship into whatever universe whatever heavenly body it is landed on is in.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be launched. Type 'help #7466:initialize' for details.");elseif ($object_utils:isa(this.location, #16043))  player:tell(this:title(), " has already been launched into ", this:universe(), ".");else  player:tell(this:launch_start_msg());  this:announce(this:olaunch_start_msg());  this.location:announce_all(this:launch_start_outside_msg());  if (!this:command_launch())    player:tell("Launch failed. There must be a permissions conflict somewhere.");    this:announce("Launch attempt failed.");    return;  else    player:tell(((this:launch_end_msg() + " ") + this:universe()) + ".");    this:announce(((this:olaunch_end_msg() + " ") + this:universe()) + ".");  endifendif"LMB #23230 01/23/2011";.@args #19950:"command_launch" this none this@program #19950:command_launchif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifthis:moveto(this.universe);if (this.location == this.universe)  old_range = this.in_range;  this:scan();  this:range_update(old_range);  return 1;else  return 0;endif"LMB #23230 01/22/2011";.@args #19950:"sensor_sweep" this none this@program #19950:sensor_sweepif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifthis.in_range = {{}, {}, {}, {}};if (!$object_utils:isa(this.location, #16043))  return;endifset = {};contents = setremove(this.universe.contents, this);for o in (contents)  if (this:valid_space_object(o) && (!o.cloaked))    set = {@set, o};@more r  endif  $command_utils:suspend_if_needed(0);endformy_coordinates = this.coordinates;same = {};near = {};med = {};long = {};for x in (set)  their_coordinates = x.coordinates;  d = this.universe:distance(my_coordinates, their_coordinates);  if (d <= 10.0)    same = {@same, x};    this:exp(x);  elseif (d <= 100.0)    near = {@near, x};  elseif (d <= 1000.0)    med = {@med, x};  elseif (d <= 10000.0)    long = {@long, x};  endif  $command_utils:suspend_if_needed(0);endforthis.in_range = {same, near, med, long};"LMB #23230 01/21/2011";.@args #19950:"sensor_update" this none this@program #19950:sensor_updateif ((!this:perm_check(caller)) && (!this:perm_check(caller_perms())))  player:tell(this:noperms_msg());  return E_PERM;endifrange = this.in_range;{ship, switch} = args;if (switch == 0)  for r in [1..4]    for s in (range[r])      if (s == ship)        range[r] = setremove(range[r], s);        break r;      endif      $command_utils:suspend_if_needed(0);    endfor    $command_utils:suspend_if_needed(0);  endfor  this.in_range = range;elseif (switch == 1)  ship_range = ship.in_range;  for r in [1..4]    for s in (ship_range[r])      if (s == this)        range[r] = setadd(range[r], ship);        break r;      endif      $command_utils:suspend_if_needed(0);    endfor    $command_utils:suspend_if_needed(0);  endforendifthis.in_range = range;"LMB #23230 01/23/2011";.@args #19950:"look_self" this none this@program #19950:look_selfif (player.location == this)  pass(@args);  if (!$object_utils:isa(this.location, #16043))    viewscreen = ("[On Viewscreen: " + this.location:title()) + "]";    player:tell(viewscreen);  else    if (this.engines)      player:tell((((((this:title() + " is currently traveling with a bearing of ") + this:bearing_report()) + (this:heading_report() ? (" toward " + this:heading_report()) + " " | " ")) + "at warp ") + tostr(this.speed)) + ".");    endif    viewscreen = ((("[On Viewscreen: " + this:universe()) + " ") + this:location_report()) + "]";    player:tell(viewscreen);  endifelse  pass(@args);endif"LMB #23230 01/22/2011";.@args #19950:"range_update" this none this@program #19950:range_updateif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifold_range = (typeof(args[1]) == LIST) ? $list_utils:flatten(args[1]) | args[1];if (typeof(old_range) == OBJ)  range = old_range;  total_range = $list_utils:flatten(this.in_range);else  range = $list_utils:flatten(this.in_range);  total_range = $list_utils:remove_duplicates($set_utils:union(range));endiffor x in (total_range)  if (($object_utils:isa(x, #19950) && $object_utils:isa(x.location, #16043)) && $set_utils:intersection(x.contents, connected_players()))    xrange = $list_utils:flatten(x.in_range);    if ((this in xrange) && $object_utils:isa(this.location, #7771))      x:announce_all((((this:oname() + " has ") + ($object_utils:isa(this.location, #19950) ? "docked at " | "landed on ")) + this.location:oname()) + ".");      x:sensor_update(this, 0);    elseif ((this in xrange) && $object_utils:isa(this.location, #21733))      x:announce_all(((this:oname() + " has crossed the event horizon of ") + this.location:oname()) + ".");      x:sensor_update(this, 0);    elseif ((typeof(range) == OBJ) && $object_utils:isa(this.location, #16043))      msg = $object_utils:isa(range, #21733) ? " has emerged from " + range:oname() | (" has launched into space from " + range:oname());      x:announce_all((this:oname() + msg) + ".");      x:sensor_update(this, 1);    else      d = this.universe:distance(this.coordinates, x.coordinates);      if ((d == 0.0) && (this.cloaked == 0))        x:announce_all(this:oname(), " has arrived in this sector.");      endif      if (((d < 10000.0) && (!(this in xrange))) && (this.cloaked == 0))        x:announce_all(this:oname(), " has entered sensor range.");        x:sensor_update(this, 1);      elseif (((d > 10000.0) || (this.cloaked == 1)) && (this in xrange))        x:announce_all(this:oname(), " is no longer in sensor range.");        x:sensor_update(this, 0);      endif    endif  endif  $command_utils:suspend_if_needed(0);endfor"LMB #23230 01/23/2011";.@args #19950:"sc*an" any none none@chmod #19950:scan rxd@program #19950:scan"Usage:  scan <any>";"  Without an argument, scans the local region of space, returning a description of the ship's surroundings, the names of any objects in sensor range, and the ship's absolute location with respect to the origin in the format (azimuth mark inclination at distance). With an object in range as an argument, scans that object. You can also scan visible phenomena more closely, like looking at details in a room description.";if (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be operated. Type 'help #7466:initialize' for details.");endif"This is very old code, but it works, so I didn't modify it very much.";this:sensor_sweep();if (caller == player)  this:announce(player:title(), " performs a sensor sweep of ", this:universe(), ".");endifif (!args)  if ($object_utils:isa(this.location, #16043))    player:tell((this:universe() + " ") + this:location_report());    player:tell_lines(this:universe_desc());    names = {};    if (length(this.in_range[1]) == 1)      x = this.in_range[1][1];      player:tell(x:oname(), " is in this sector.");    elseif (length(this.in_range[1]) > 1)      for n in (this.in_range[1])        name = ($object_utils:isa(n, #7771) && (!$object_utils:isa(n, #19950))) ? "*" + n:oname() | ($object_utils:isa(n, #9602) ? "@" + n:oname() | n:oname());        names = {@names, name};        $command_utils:suspend_if_needed(0);      endfor      player:tell($string_utils:english_list(names), " are in this sector.");    endif    if (length(this.in_range[2]) == 1)      x = this.in_range[2][1];      player:tell(x:oname(), " is nearby.");    elseif (length(this.in_range[2]) > 1)      for n in (this.in_range[2])        name = ($object_utils:isa(n, #7771) && (!$object_utils:isa(n, #19950))) ? "*" + n:oname() | ($object_utils:isa(n, #9602) ? "@" + n:oname() | n:oname());        names = {@names, name};        $command_utils:suspend_if_needed(0);      endfor      player:tell($string_utils:english_list(names), " are nearby.");    endif    if (length(this.in_range[3]) == 1)      x = this.in_range[3][1];      player:tell(x:oname(), " is in medium sensor range.");    elseif (length(this.in_range[3]) > 1)      for n in (this.in_range[3])        name = ($object_utils:isa(n, #7771) && (!$object_utils:isa(n, #19950))) ? "*" + n:oname() | ($object_utils:isa(n, #9602) ? "@" + n:oname() | n:oname());        names = {@names, name};        $command_utils:suspend_if_needed(0);      endfor      player:tell($string_utils:english_list(names), " are in medium sensor range.");    endif    if (length(this.in_range[4]) == 1)      x = this.in_range[4][1];      player:tell(x:oname(), " is in long sensor range.");    elseif (length(this.in_range[4]) > 1)      for n in (this.in_range[4])        name = ($object_utils:isa(n, #7771) && (!$object_utils:isa(n, #19950))) ? "*" + n:oname() | ($object_utils:isa(n, #9602) ? "@" + n:oname() | n:oname());        names = {@names, name};        $command_utils:suspend_if_needed(0);      endfor      player:tell($string_utils:english_list(names), " are in long sensor range.");    endif  else    this:look_outside();    this.location:announce_all(this:oscan_msg(), " ", this.location:title(), ".");  endifelse  if ($object_utils:isa(this.location, #16043))    "Handle phenomenon details.";    phenomenon = this:universe();    ph_index = (phenomenon == this.universe:title()) ? 0 | (phenomenon in this.universe.pnames);    if (ph_index && (details = this.universe.pdetails[ph_index]))      match = $string_utils:find_prefix(argstr, details[1]);      if (match)        return player:tell_lines(details[2][match]);      elseif (ph = $string_utils:find_prefix(argstr, this.universe.pnames))        return player:tell_lines(this.universe.pdescs[ph]);      elseif ($string_utils:find_prefix(argstr, this.universe:title()))        player:tell_lines(this.universe:description());      endif    endif    range = $list_utils:flatten(this.in_range);    match = $string_utils:match(argstr, range, "oname");    if ((match == $failed_match) || (!this:valid_space_object(match)))      player:tell("There is no '", argstr, "' in sensor range.");    elseif (match == $ambiguous_match)      player:tell("'", argstr, "' can refer to more than one object in sensor range. Be more specific.");    else      player:tell(match:oname(), " ", match:location_report(), " is in ", match:universe(), ".");      player:tell_lines(match:odescription());      if ($object_utils:isa(match, #7771) && (!$object_utils:isa(match, #19950)))        player:tell(match:oname(), " is a heavenly body. Perhaps you can land on it?");      elseif ($object_utils:isa(match, #9602))        player:tell(match:oname(), " is some sort of astrophysical anomaly. Perhaps you can learn more about it?");      elseif ($object_utils:isa(match, #19950) && match.engines)        player:tell(match:oname(), " is traveling with a bearing of ", match:bearing_report(), " at warp ", match.speed, ".");      endif    endif  else    range = this.location.contents;    match = $string_utils:match(argstr, range, "aliases");    if (match == $failed_match)      player:tell("There is no '", argstr, "' in ", this.location:title(), ".");    elseif (match == $ambiguous_match)      player:tell("'", argstr, "' can refer to more than one object in ", this.location:title(), ". Be more specific.");    else      match:look_self();      if (is_player(match) && (match in connected_players()))        match:tell(this:scan_msg());        match.location:announce_all_but({match}, ((this:oscan_msg() + " ") + match:title()) + ".");      endif    endif  endifendif"LMB #23230 01/23/2011";.@args #19950:"lan*d" any none none@program #19950:land"Usage:  land <location>";"  Lands the ship at the specified location, if possible. Only trusted ships may land at locations where the trusted ship list is not empty.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be launched. Type 'help #7466:initialize' for details.");elseif (!$object_utils:isa(this.location, #16043))  player:tell(this:title(), " is already landed on ", this.location:title(), ".");elseif (!args)  return player:tell("Usage:  land <location>");else  range = this.in_range[1];  planet = argstr;  match = $string_utils:match(planet, range, "oname");  all_range = $list_utils:flatten(this.in_range);  out_of_range = $string_utils:match(planet, $set_utils:difference(all_range, range), "oname");  if (out_of_range)    return player:tell(this:title(), " must be in the same sector as ", out_of_range:oname(), " in order to attempt landing on it.");  endif  if ((match == $failed_match) || (!this:valid_space_object(match)))    player:tell("There is no '", planet, "' in this sector.");  elseif (match == $ambiguous_match)    player:tell("'", planet, "' can refer to more than one object in sensor range. Be more specific.");  elseif (!$object_utils:isa(match, #7771))    player:tell(match:oname(), " cannot be landed on.");  elseif (match:trusted_ships() && (!(this in setadd(match:trusted_ships(), #8510))))    player:tell(this:title(), " is not permitted to land at ", match:oname(), ".");  else    player:tell(((this:land_start_msg() + " ") + match:oname()) + ".");    this:announce(((this:oland_start_msg() + " ") + match:oname()) + ".");@more r    if (this:command_land(match))      this:scan();      player:tell(((this:land_end_msg() + " ") + match:oname()) + ".");      this:announce(((this:oland_end_msg() + " ") + match:oname()) + ".");      this.location:announce(this:land_end_outside_msg());      this.in_range = this.location;    else      player:tell(this:title(), " cannot seem to land at ", match:oname(), ". There might be a permissions problem or else ", match:oname(), " doesn't want you.");      this:announce($object_utils:isa(match, #19950) ? "Dock" | "Land", " attempt failed.");    endif  endifendif"LMB #23230 01/23/2011";.@args #19950:"command_land" this none this@program #19950:command_landif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifplanet = args[1];this:moveto(planet);if (this.location == planet)  this:range_update(this.in_range);  return 1;else  return 0;endif"LMB #23230 01/23/2011";.@args #19950:"look_outside" this none this@program #19950:look_outsideplayer:tell_lines(this.location:title());desc = this.location:description();if (desc)  player:tell_lines(desc);else  player:tell("You see nothing special.");endifif ($object_utils:has_callable_verb(this.location, "tell_integration"))  this.location:tell_integration();endifthis.location:tell_contents(setremove(this.location.contents, this), 3);"LMB #23230 09/30/2000";.@args #19950:"ent*er bo*ard go" this none none@program #19950:enter"Usage:  enter <this>";"  Board the ship. If you have :moveto() protection, this command may not function.";if ((player.location == this) || $object_utils:isa(this.location, #16043))  player:tell("I don't understand that.");else  player:moveto(this);  if (player.location != this)    player:tell("You seem unable to board ", this:oname(), ". Make sure you don't have moveto() protection.");  else    player:tell(this:board_msg());    this:announce(this:oboard_msg());    this.location:announce(this:oboard_depart_msg());  endifendif"LMB #23230 01/22/2011";.@args #19950:"ex*it disem*bark out" none none none@program #19950:exit"Usage:  exit";"  Exit the ship. You cannot exit a ship while it is in space.";if (player.location != this)  return player:tell("I don't understand that.");endifif ($object_utils:isa(this.location, #16043))  player:tell("You cannot exit ", this:title(), " until it lands.");else  player:moveto(this.location);  if (player.location == this)    player:tell("You seem unable to exit ", this:title(), ". Make sure you don't have moveto() protection.");  else    player:tell(this:disembark_msg());    this:announce(this:odisembark_msg());    this.location:announce(this:odisembark_arrive_msg());  endifendif"LMB #23230 01/20/2011";.@args #19950:"enterfunc confunc" this none this@program #19950:enterfuncpass(@args);if (is_player(caller) && this:perm_check(caller))  player:tell(this:commander_msg());  this:announce(this:ocommander_msg());endif"LMB #23230 01/22/2011";.@args #19950:"sp*eed" any none none@more r@program #19950:speed"Usage:  speed | speed <new speed>";"  Displays the current speed of the ship or sets a new one.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can be launched. Type 'help #7466:initialize' for details.");endifif (!args)  player:tell(this:title(), " is currently set to travel at warp ", this.speed, ".");else  speed = tofloat(argstr);  if ((speed < 1.0) || (speed > 10.0))    player:tell("'", argstr, "' is an incorrect speed setting. ", this:title(), " can only be set to travel between warp 1 and warp 10.");  else    this.speed = tofloat(speed);    this.speed = speed;    player:tell(this:title(), " is now set to travel at warp ", speed, ".");    this:announce(player:title(), " set ", this:title(), " to travel at warp ", speed, ".");  endifendif"LMB #23230 01/23/2011";.@args #19950:"head*ing bear*ing" any any any@program #19950:heading"Usage:  bearing <radius> <azimuth> <inclination> | heading <destination>";"  There are two ways to navigate in MOOSpace. The first is to enter a bearing, which is a specific location to which you want to travel expressed in spherical coordinates. The radius is the absolute distance of the location from the origin point, the azimuth is the angle >= 0.0 and < 360.0 degrees between, e.g., the line pointing toward the center of the galaxy and the ship's direction of travel, and the inclination is the angle >= 0.0 and <= 180.0 degrees between, e.g., the line pointing toward the north pole of the galaxy and the ship's direction of travel, with 90.0 degrees being level with, e.g. the galactic plane (or however you want to imagine the structure of the universe). If you want to travel on a true bearing, you can enter a very high radius value, though it takes about a day to travel 100,000 light years if the task isn't killed. The second way to navigate is to enter a heading, which in this system is simply the name of a specific object, e.g. a planet or other heavenly body, toward which you wish to navigate. In order to navigate with a heading, you must have visited the named object before.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before the navigation system can be used. Type 'help #7466:initialize' for details.");elseif (!$object_utils:isa(this.location, #16043))  return player:tell(this:title(), " must be launched before its navigation system can be used.");elseif (!args)  msg = (this:title() + ((verb[1] == "b") ? " has a bearing of " + this:bearing_report() | (this.heading ? " is heading toward " + this:heading_report() | " does not currently have a heading"))) + ".";  return player:tell(msg);elseif ((verb[1] == "b") && (length(args) == 3))  {r, theta, phi} = args;  r = `tofloat(r) ! E_INVARG => 0';  theta = `tofloat(theta) ! E_INVARG => 0';  phi = `tofloat(phi) ! E_INVARG => 0';  if ((((((((r == 0) || (theta == 0)) || (phi == 0)) || (r < 0.0)) || (theta < 0.0)) || (theta >= 360.0)) || (phi < 0.0)) || (phi > 180.0))    player:tell("A bearing must be entered as three numbers: a radius greater than or equal to 0; an azimuth angle greater than or equal to 0 and less than 360; and an inclination angle greater than 0 and less than or equal to 180.");  else    this.bearing = {r, theta, phi};    player:tell(this:title(), " is now set with a bearing of ", this:bearing_report(), ".");    this:announce(player:title(), " has set ", this:title(), " with a bearing of ", this:bearing_report(), ".");  endifelseif (verb[1] == "h")  if (heading = this:find_heading(argstr))    this.heading = heading;    player:tell(this:title(), " is now set on a heading toward ", heading:oname(), ".");    this:announce(player:title(), " has set ", this:title(), " on a heading toward ", heading:oname(), ".");  elseif (heading == $failed_match)    player:tell("Your ship's navigation system does not know where '", argstr, "' is. Perhaps you haven't discovered it yet?");  elseif (heading == $ambiguous_match)    player:tell("'", argstr, "' can refer to more than one heading. Be more specific.");  endifelse  command = (verb[1] == "b") ? "bearing <radius> <azimuth> <inclination>" | "heading <destination>";  return player:tell("Usage:  ", command);endif"LMB #23230 01/23/2011";.@args #19950:"h*ail" any any any@program #19950:hail"Usage:  hail <ship> or <player> <message>";"  Send a message to another ship in sensor range. When landed, you can use this command to send a message to a player on the same planet as your ship.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before it can engage in ship to ship communications. Type 'help #7466:initialize' for details.");elseif (length(args) < 2)  return player:tell("Usage: hail <ship> or <player> <message>");endifif (!$object_utils:isa(this.location, #16043))  recipient = $string_utils:explode(args[1])[1];  command = $string_utils:from_list($string_utils:explode(argstr)[2..$], " ");  match = $string_utils:match_player(recipient);  if (match in connected_players())    msg = $string_utils:trim(command);    dobj = match;    player:tell(this:hail_origin_msg(), " \"", msg, "\"");    this:announce(this:ohail_origin_msg(), " \"", msg, "\"");    match:tell(this:hail_receive_msg(), " \"", msg, "\"");  elseif (match == $ambiguous_match)    player:tell("'", argstr, "' can refer to more than one player. Be more specific.");  elseif (match == $failed_match)    player:tell("There is no player called '", argstr, "' at ", this.location:title(), ".");  else    player:tell(match:title(), " is unable to receive hails at this time.");  endifelse  command = argstr;  target = $string_utils:explode(args[1])[1];  range = $list_utils:flatten(this.in_range);  match_list = {};  for r in (range)    name = r:oname() + "*";    if ($string_utils:match_string(command, name) || $string_utils:match_object(target, this.universe))      match_list = setadd(match_list, r);    endif    $command_utils:suspend_if_needed(0);  endfor  if (length(match_list) > 1)    player:tell("'", argstr, "' can refer to more than one ship within sensor range. Be more specific.");  elseif (!match_list)    player:tell("There is no ship called '", argstr, "' within sensor range.");  else    ship = match_list[1];    dobj = ship;    msg = $string_utils:trim($string_utils:from_list($string_utils:match_string(command, ship:oname() + "*")));    player:tell(this:hail_origin_msg(), " \"", msg, "\"");    this:announce(this:ohail_origin_msg(), " \"", msg, "\"");    ship:announce_all(this:hail_receive_msg(), " \"", msg, "\"");  endifendif"LMB #23230 01/23/2011";.@args #19950:"eng*age dis*engage" none none none@program #19950:engage"Usage:  engage | disengage";"  Activates or deactivates the ship's engines. When you engage the ships engines, it will proceed to travel at the current speed, which may be modified en route, until it arrives at the current bearing, which may also be modified en route.";if ((this.permitted != {}) && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;elseif (!this:valid_space_object())  return player:tell(this:title(), " must be initialized before its engines can be engaged. Type 'help #7466:initialize' for details.");elseif (!$object_utils:isa(this.location, #16043))  player:tell(this:title(), " must be launched before its engines can be engaged.");else  if (verb[1] == "e")    if (this.engines)      return player:tell(this:title(), "'s engines are already engaged.");    elseif ((this.bearing == this.coordinates) || (this.universe:distance(this.bearing, this.coordinates) == 0.0))      return player:tell(this:title(), " is already located at its current bearing.");    endif    this.engines = 1;    player:tell(this:engage_origin_msg());    this:announce(this:oengage_origin_msg());    if (this:engines() && (this.universe:distance(this.coordinates, this.bearing) == 0.0))      this:scan();      player:tell(this:engage_arrive_msg());      this:announce(this:oengage_arrive_msg());    elseif (this.engines)      this:announce_all(this:title(), " seems to be experiencing a warp drive malfunction. Engines disengaged.");    endif    this.engines = 0;  elseif (verb[1] == "d")    if (!this.engines)      return player:tell(this:title(), "'s engines are not currently engaged.");    endif    this.engines = 0;    player:tell(this:disengage_msg());    this:announce(this:odisengage_msg());    this:range_update(this.in_range);  endifendif"LMB #23230 01/23/2011";.@args #19950:"engines" this none this@program #19950:enginesif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif"This function moves the ship using vector math.";"while (this.universe:distance(this.coordinates, this.bearing) > (this.speed))";"  speed = this.speed;";"  midpoint = this:midpoint(this.coordinates, this.bearing);";"  while (d = this.universe:distance(this.coordinates, midpoint) > (speed))";"    midpoint = this:midpoint(this.coordinates, midpoint);";"  endwhile";"  this.coordinates = midpoint;";"endwhile";" <----- OLD CODE ABOVE, NEW CODE BELOW ----->";origin = this.coordinates;chars = {".", "@", "*", "+", "o", ".", "@", "*", "+", " "};count = 0;while (((d = this.universe:distance(this.coordinates, this.bearing)) > 0.0) && this.engines)  count = count + 1;  stars = {};  for s in [1..79]    mod = random(50);    stars = (mod <= 10) ? {@stars, chars[mod]} | {@stars, " "};  endfor  speed = this.speed;  {x1, y1, z1} = this.universe:convert(this.coordinates);  {x2, y2, z2} = this.universe:convert(this.bearing);  {xv, yv, zv} = this:normalize({x1, y1, z1}, {x2, y2, z2});  x = x1 + (speed * xv);  y = y1 + (speed * yv);  z = z1 + (speed * zv);@more r  old_range = this.coordinates;  this.coordinates = this.universe:aconvert({x, y, z});  this.coordinates[2] = this.bearing[2];  this.coordinates[3] = this.bearing[3];  "Do something here.";  this:range_update(old_range);  suspend(1);  if (d <= speed)    suspend(1);    this.coordinates = this.bearing;  endif  if ($command_utils:running_out_of_time())    this:announce_all(this:title(), " is passing through an unstable area of space and needs a moment to stabilize.");    suspend(60);    this:announce_all(this:title(), " has successfully stabilized.");  endif  if ((count == 10) && $set_utils:intersection(this.contents, connected_players()))    this:announce_all($string_utils:center($string_utils:from_list(stars), 79));    count = 0;  endifendwhilereturn ((this.coordinates == origin) || (this.universe:distance(this.coordinates, origin) == 0.0)) ? 0 | 1;"LMB #23230 01/23/2011";.@args #19950:"commander_msg ocommander_msg launch_start_msg olaunch_start_msg launch_start_outside_msg launch_end_msg olaunch_end_msg board_msg oboard_msg oboard_depart_msg disembark_msg odisembark_msg odisembark_arrive_msg land_start_msg oland_start_msg land_end_msg oland_end_msg land_end_outside_msg scan_msg oscan_msg disengage_msg odisengage_msg engage_origin_msg oengage_origin_msg engage_arrive_msg oengage_arrive_msg hail_origin_msg ohail_origin_msg hail_receive_msg" this none this@program #19950:commander_msg"Verb -> property matching for messages defined on this object not defined on parents.";return $object_utils:has_property(this, verb) ? (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "" | "";"LMB #23230 01/09/2011";.@args #19950:"here_huh" this none this@program #19950:here_huh"Look for something to do on an astrophysical anomaly.";if (this.permitted && (!this:perm_check(caller)))  player:tell(this:noperms_msg());  return E_PERM;endif{verb, ?target = ""} = args;if (target && this:valid_space_object())  range = this.in_range[1];  anomaly = 0;  for o in (range)    if (($object_utils:isa(o, #9602) && match(o:title(), target)) && $object_utils:match_verb(o, verb))      anomaly = o;      verb = $object_utils:match_verb(o, verb)[2];    endif    $command_utils:suspend_if_needed(0);  endfor  if (anomaly && this:valid_space_object(anomaly))    anomaly:(verb)();    return 1;  else    pass(@args);  endifelse  pass(@args);endif"LMB #23230 01/22/2011";.@args #19950:"bearing_report" this none this@program #19950:bearing_report{r, theta, phi} = this.bearing;r = tostr(r);theta = tostr(theta);phi = tostr(phi);return ((((theta + " mark ") + phi) + " at ") + r) + " light years";"LMB #23230 01/22/2011";.@args #19950:"heading_report" this none this@program #19950:heading_reportreturn this.heading ? this.heading:oname() | 0;"LMB #23230 01/22/2011";.@args #19950:"exp" this none this@program #19950:expif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifitem = args[1];if (!(item in this.explored))  this.explored = {@this.explored, item};endif"LMB #23230 01/20/2011";.@args #19950:"midpoint" this none this@program #19950:midpoint"Returns the spherical coordinates of the midpoint of a line defined by the arguments, which should both also be sets of spherical coordinates.";{a, b} = args;universe = this.universe;{x1, y1, z1} = universe:convert(a);{x2, y2, z2} = universe:convert(b);midpoint = {0.5 * (x1 + x2), 0.5 * (y1 + y2), 0.5 * (z1 + z2)};return this.universe:aconvert(midpoint);"LMB #23230 01/21/2011";.@args #19950:"normalize" this none this@program #19950:normalize"Normalizes a vector given in two sets of Cartesian coordinates. That is, returns the corresponding (x, y, z) values for the unit vector of the given vector, which should be supplied as a start and end point, respectively.";{origin, dest} = args;{x1, y1, z1} = origin;{x2, y2, z2} = dest;ax = x2 - x1;ay = y2 - y1;az = z2 - z1;mag = sqrt(((ax ^ 2) + (ay ^ 2)) + (az ^ 2));`xv = ax / mag ! E_DIV => 0.0';`yv = ay / mag ! E_DIV => 0.0';`zv = az / mag ! E_DIV => 0.0';return {xv, yv, zv};"LMB #23230 01/21/2011";.@args #19950:"who_location_msg" this none this@program #19950:who_location_msgreturn ((pass(@args) + " [") + this:universe()) + "]";"LMB #23230 01/22/2011";.@args #19950:"title" this none this@program #19950:titleif (player.location != this)  return this:oname();else  return (this:oname() == this.name) ? pass(@args) | this:oname();endif"LMB #23230 01/22/2011";.@more r@args #19950:"find_heading" this none this@program #19950:find_headingif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifsearch = args[1];exp = this.explored;result = $string_utils:match(search, exp, "oname");return result;"LMB #23230 01/22/2011";.@args #19950:"loc*ation" none none none@program #19950:locationplayer:tell(this:title(), " is in ", this:universe(), " ", this:location_report());"LMB #23230 01/23/2011";."***finished***iYou are carrying:Tricorder (#22140)                 [MOOSpace] Generic Interstellar Cra[MOOSpace] Generic Space Object (# [MOOSpace] Generic Astrophysical An[MOOSpace] Generic Universe (#1604 [MOOSpace] Generic Wormhole (#21733[MOOSpace] Generic Heavenly Body ( @dump gu@chmod #16043."permitted" ;#16043.("permitted") = {}@chmod #16043."noperms_msg" r;#16043.("noperms_msg") = ""@chmod #16043."pnames" r;#16043.("pnames") = {}@chmod #16043."pdescs" r;#16043.("pdescs") = {}@chmod #16043."pvalues" ;#16043.("pvalues") = 0@chmod #16043."p_shapes" r;#16043.("p_shapes") = {"sphere", "ellipsoid", "torus", "elliptical torus"}@chmod #16043."pdetails" ;#16043.("pdetails") = {};#16043.("entrances") = {};#16043.("exits") = {};#16043.("key") = 0;#16043.("aliases") = {"[MOOSpace] Generic Universe", "gu"};#16043.("description") = "A universe in MOOSpace is basically a container for all the space objects within it--a room of rooms that you have to imagine is infinite in extent. According to Richard Bartle, this is the sort of act of fancy that makes text-based virtual worlds superior to graphics-based ones. Universes also have regional features, called phenomena, that can affect starship navigation in various ways. Generally speaking, you won't need to create children of this object (or more than one, at least) unless you want to have your own dimension for ships, etc. to explore. Theoretically, you could create a whole series of universes and string them together into a multiverse, but it would take someone quite a long time to explore it!";#16043.("object_size") = {35834, 1295850919}"#16043.("original_owner") => E_PERM (Permission denied)"#16043.("days_left") => E_PERM (Permission denied);#16043.("creation_date") = 969427835"#16043.("queued_task_limit") => E_PERM (Permission denied)@args #16043:"@add-p*henomenon @addp*henomenon @remove-p*henomenon @removep*henomenon @rm-p*henomenon @rmp*henomenon" any none none@program #16043:@add-phenomenon"Usage:  @add-phenomenon <name> | @remove-phenomenon <name>";*** More ***  66 lines left.  Do @more [rest|flush] for more.@more r"  Adds or removes a cosmic phenomenon to this universe. A phenomenon is an area of space defined according to its shape. The default shapes are sphere, ellipsoid, torus, and elliptical torus. Additional shapes may be defined. A ship within the boundaries of a phenomenon will see a different name and description when it scans its present position in space. Use phenomena for such things as galaxies, star systems, nebulae, or whatever other weird things you can devise. Since phenomena can overlap, you can rearrange them or even add speed limits for ships traveling through them using the @set-phenomenon command.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!dobjstr)  return player:tell("Usage: @", (verb[2] == "r") ? "remove-phenomenon" | "add-phenomenon", " <name>");endifname = dobjstr;if (verb[2] == "r")  if (this:remove_phenomenon(name))    player:tell(name, " has been removed from ", this:title(), ".");  else    player:tell("There is no phenomena called ", name, " defined on ", this:title(), ".");  endifelseif (verb[2] == "a")  if (results = this:match_phenomenon(name))    index = results[1];    question = (length(results) == 1) ? ((("There is a phenomenon called " + this.pnames[index]) + " already defined on ") + this:title()) + ". Do you want to write a new description for it? Answer 'yes' to replace the description. Otherwise a new phenomenon will be created." | (((((("There are " + length(results)) + " phenomena with the name ") + this.pnames[index]) + " already defined on ") + this:title()) + ". Do you want to write a new description for them? Answer 'yes' to replace the descriptions. Otherwise, a new phenomenon will be created.");    if ($string_utils:find_prefix($command_utils:read(player:tell(question)), {"yes", "1"}))      desc = $command_utils:read_lines(player:tell("Enter a new description for ", this.pnames[index], ":"));      for p in (results)        this.pdescs[p] = desc;        $command_utils:suspend_if_needed(0);      endfor      return player:tell("Description changed.");    endif  endif  player:tell("Enter a description for ", name, ":");  desc = $command_utils:read_lines();  shape = 0;  "If you want to define additional shapes, you should: 1. append the name of the shape as a string to this.p_shapes, 2. create a verb with the same name, replacing any spaces between words with underscores so the verb can be called internally, 3. program the verb collect the necessary values from the player to create the shape and store them in this.pvalues (see the original shape verbs for guidance), 4. create a verb called [shape]_contains where [shape] is the same name used above, and 5. program that verb to take as arguments a list of spherical coordinates in {radius, azimuth, inclination} form and a list of values from this.pvalues and return true if the coordinates are inside the specified phenomenon and false otherwise. This is easier than it sounds.";  while ((shape < 1) || (shape > length(this.p_shapes)))    player:tell("What shape do you want ", name, " to have? Enter a number:");    player:tell();    for sh in [1..length(this.p_shapes)]      player:tell(sh, ". ", this.p_shapes[sh]);    endfor    shape = toint($command_utils:read());  endwhile  shape_name = this.p_shapes[shape];  if ($object_utils:has_callable_verb(this, shape_name = $string_utils:substitute(shape_name, {{" ", "_"}})))    verb = shape_name;    this:(verb)(name, desc);  else    player:tell(this:title(), " is not capable of creating a ", shape_name, ". Command aborted.");    return;  endif  player:tell("A phenomenon called ", name, " shaped like ", ($string_utils:a_or_an(shape_name) + " ") + $string_utils:substitute(shape_name, {{"_", " "}}), " has been added to ", this:title(), ".");endif"LMB #23230 01/18/2011";.@args #16043:"@pheno*mena" none none none@program #16043:@phenomena"Usage:  @phenomena";"  Lists the phenomena defined on this universe and their details.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (this.pnames == {})  player:tell("There are no phenomena defined on ", this:title(), ".");else  player:tell("Phenomena defined on ", this:title(), " (bottom to top):");  index = 0;  for p in (this.pnames)    index = index + 1;    coordinates = ((((("(" + tostr(this.pvalues[index][1][1])) + ", ") + tostr(this.pvalues[index][1][2])) + ", ") + tostr(this.pvalues[index][1][3]))  + ")";    shape = this.p_shapes[this.pvalues[index][3]];    limit_text = ((limit = this.pvalues[index][4]) > 0) ? "a speed limit of warp " + tostr(limit) | "no speed limit";    player:tell(index, ". ", p, " with origin point at coordinates ", coordinates, " shaped like ", $string_utils:a_or_an(shape), " ", shape, " and with ", limit_text, ".");    if (data_string = this:phenomenon(index))      player:tell("   " + data_string);    endif    if ($list_utils:flatten(this.pdetails[index]))      details = {};      for pd in (this.pdetails[index][1])        details = {@details, pd};        $command_utils:suspend_if_needed(0);      endfor      player:tell("   Details defined on ", p, ": ", $string_utils:english_list(details), ".");    endif    $command_utils:suspend_if_needed(0);  endforendif"LMB #23230 01/19/2011";.< disconnected: Rita. Total: 6 >@args #16043:"distance" this none this@program #16043:distance"Converts two sets of spherical coordinates into Cartesian coordinates and calculates the distance between them. You can hack this procedure for your universe if you want to define your own physics.";{x1, y1, z1} = this:convert(args[1]);{x2, y2, z2} = this:convert(args[2]);distance = sqrt((((x2 - x1) ^ 2.0) + ((y2 - y1) ^ 2.0)) + ((z2 - z1) ^ 2.0));"Because of the limitations of floating point calculations, it is necessary to reduce the precision of the extremely long decimals that will sometimes result from this procedure.";return tofloat(floatstr(distance, 10));"LMB #23230 01/08/2011";.@args #16043:"convert aconvert" this none this@program #16043:convert"The convert() function converts spherical into Cartesian coordinates, and aconvert() is vice versa. The positive x-axis in Cartesian is identical to the projection of 0 degrees of azimuth (theta) in the spherical system, and the positive y-axis is identical to the projection of 0 degrees of inclination (phi).";if (verb == "convert")  {r, theta, phi} = args[1];  if (((!(r >= 0.0)) || (!((theta >= 0.0) && (theta < 360.0)))) || (!((phi >= 0.0) && (phi <= 180.0))))    return E_INVARG;  else    theta = this:radians(theta);    phi = this:radians(phi);    x = (r * cos(theta)) * sin(phi);    y = (r * sin(theta)) * sin(phi);    z = r * cos(phi);    return {x, y, z};  endifelseif (verb == "aconvert")  {x, y, z} = args[1];  r = sqrt(((x ^ 2.0) + (y ^ 2.0)) + (z ^ 2.0));@more r  theta = atan(y, x);  phi = `acos(z / r) ! E_DIV => 0';  "atan() returns a value between -pi and pi, but MOOSpace uses 360 degrees for azimuth, so any values less than zero (that is, in the range 0 to -180 degrees) are simply subtracted from 360 after conversion from radians to degrees.";  theta = (theta < 0.0) ? 360.0 - abs(this:degrees(theta)) | this:degrees(theta);  phi = this:degrees(phi);  return {r, theta, phi};endif"LMB #23230 01/23/2011";.@args #16043:"degrees" this none this@program #16043:degrees"Converts radians into degrees.";return tofloat(args[1]) * 57.2957795130823;"LMB #23230 01/07/2011";.@args #16043:"radians" this none this@program #16043:radians"Converts degrees into radians.";return tofloat(args[1]) * 0.0174532925199433;"LMB #23230 01/07/2011";.@args #16043:"perm_check" this none this@program #16043:perm_check"Takes a single object as an argument, usually the value of caller if passed from the command line and caller_perms() otherwise. Returns true if the object (typically a player) is this, this.owner, listed in this.permitted, or a wizard. Returns false otherwise or if the argument list is the wrong length. This is a permissions check meant to prevent verb spoofing. Every command verb defined on MOOSpace objects should use it. Since it's so important, perm_check() does considerable maintenance on this.permitted whenever it's called.";{?TestCase = 0, @rest} = args;if (!$perm_utils:controls(caller_perms(), this))  return E_PERM;elseif ((typeof(TestCase) != OBJ) || rest)  return E_ARGS;elseif (!$object_utils:has_property(this, "permitted"))  player:tell("** ERROR: The .permitted property on ", this.name, " is either missing or broken.");  return $perm_utils:controls(caller_perms(), this);elseif (typeof(this.permitted) != LIST)  this.permitted = {};endiftrusted_list = {#23230, this};permitted_list = this.permitted;"The for loop below makes sure the objects in this.permitted are valid (i.e. they exist and haven't been recycled) and cleans it up if necessary.";for trusted_object in (permitted_list = $list_utils:remove_duplicates($list_utils:flatten(permitted_list)))  $command_utils:suspend_if_needed(0);  if ((typeof(trusted_object) == OBJ) && $recycler:valid(trusted_object))    trusted_list = {@trusted_list, trusted_object};  else    permitted_list = setremove(permitted_list, trusted_object);  endifendforthis.permitted = permitted_list;return (TestCase in trusted_list) || $perm_utils:controls(TestCase, this);"LMB #23230 01/23/2011";.@args #16043:"@permit @trust" any any any@program #16043:@permit"Usage:  @permit <any player> | @permit -<any player>";"  Commissions a player other than the owner to operate or modify this space object. Only the owner, however, can use this command. Use a minus sign '-' in front of the player's name to decommission that player";if (!$perm_utils:controls(caller, this))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  permitted_list = $list_utils:remove_duplicates({this.owner, @this.permitted});  player:tell($string_utils:title_list(permitted_list), (permitted_list == {this.owner}) ? " is " | " are ", $string_utils:pronoun_sub("permitted to operate and modify %t."));elseif (dobjstr[1] == "-")  match = $string_utils:match(dobjstr[2..$], {this.owner, @this.permitted}, "aliases");  if ((match == this.owner) && (this.permitted == {}))    player:tell("You cannot decommission yourself!");  elseif (match in this.permitted)    this.permitted = setremove(this.permitted, match);    player:tell(match:title(), $string_utils:pronoun_sub(" is no longer commissioned to operate or modify %t."));  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  else    player:tell(dobjstr, $string_utils:pronoun_sub(" is not the name of any player currently commissioned to operate and modify %t."));  endifelse  match = $string_utils:match_player(tostr(dobjstr));  if (match == $failed_match)    player:tell("No player called ", dobjstr, " can be found. Try using the player's object number instead.");  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  elseif (match in this.permitted)    player:tell(match:title(), $string_utils:pronoun_sub(" is already permitted to operate and modify %t."));  else    this.permitted = {@this.permitted, match};    player:tell(match:title(), $string_utils:pronoun_sub(" is now commissioned to operate and modify %t."));  endifendif"LMB #23230 01/23/2011";.@args #16043:"@set-p*henomenon @setp*henomenon" any any any@program #16043:@set-phenomenon"Usage:  @set-phenomenon <phenomenon> move up/down/top/bottom | @set-phenomenon <phenomenon> to <speed>";"  Rearranges the match order of a phenomenon defined on this universe or changes the maximum speed of ships passing through it. The first usage of the verb is useful if you want, e.g., a default phenomenon of a significant size, like a galaxy, to sit underneath more specific and localized phenomena like nebulae and such which take precedence. The second usage of the verb changes the speed limit of the phenomenon, which might make sense of the phenomenon is meant to represent an area of strong gravity or material density.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif{?ph = "", @extra_words, ?do = "", ?parameter = ""} = args;if (extra_words)  ph = (ph + " ") + $string_utils:from_list(extra_words, " ");endifif (ph && (!(p_index = this:match_phenomenon(ph))))  return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");elseif (parameter && (do == "move"))  if (length(this.pnames) == 1)    return player:tell("There is only one phenomenon defined on ", this:title(), ".");  endif  for p in (p_index)    pname = this.pnames[p];    pdesc = this.pdescs[p];    pvalue = this.pvalues[p];    pdetails = this.pdetails[p];    r = 0;    if ((parameter[1] == "u") && (p < length(this.pnames)))      r = p + 1;      player:tell(pname, " moved above ", this.pnames[r], ".");    elseif ((parameter[1] == "d") && (p > 1))      r = p - 1;      player:tell(pname, " moved below ", this.pnames[r], ".");    elseif ((parameter[1] == "t") && (p < length(this.pnames)))      r = length(this.pnames);      player:tell(pname, " moved to the top of the list, above ", this.pnames[r], ".");    elseif ((parameter[1] == "b") && (p > 1))      r = 1;      player:tell(pname, " moved to the bottom of the list, below ", this.pnames[r], ".");    else      player:tell(this.pnames[p], " unchanged.");    endif    if (r)      rname = this.pnames[r];      rdesc = this.pdescs[r];      rvalue = this.pvalues[r];      rdetails = this.pdetails[r];      this.pnames[r] = pname;      this.pnames[p] = rname;      this.pdescs[r] = pdesc;      this.pdescs[p] = rdesc;      this.pvalues[r] = pvalue;      this.pvalues[p] = rvalue;      this.pdetails[r] = pdetails;      this.pdetails[p] = rdetails;      "There must be an easier way of doing this. I suppose I could have written a swapping function, but it's such a low-intensity operation.";    endif    $command_utils:suspend_if_needed(0);  endforelseif ((parameter && (do == "to")) && $string_utils:is_numeric($string_utils:explode(parameter, ".")[1]))  speed = toint(parameter);  for p in (p_index)    if (this.pvalues[p][4] == speed)      return player:tell(this.pnames[p], " is already set to a speed limit of ", speed, ".");    elseif ((speed < 0) || (speed > 10))      return player:tell(speed, " is an invalid speed limit. Enter 0 for no speed limit or a speed of 1-10.");    endif    this.pvalues[p][4] = speed;    player:tell("The speed limit of ", this.pnames[p], " is now warp ", speed, ".");    if (speed == 10)      player:tell("Note: if the speed limit is set to 10, ships will not be able to enter the area of space defined by ", this.pnames[p], ".");    endif    $command_utils:suspend_if_needed(0);  endforelse  return player:tell("Usage:  @set-phenomenon <phenomenon> move up/down/top/bottom | @set-phenomenon <phenomenon> to <speed>");endif"LMB #23230 01/18/2011";.@args #16043:"noperms_msg" this none this@chmod #16043:noperms_msg rx@program #16043:noperms_msg"Copied from Improved Generic-All-In-One Room (#7424):noperms_msg by Rat (#4385) Sat Jan  8 16:58:31 2011 PST";return this.(verb) ? this.(verb) | E_PERM;.@args #16043:"@clear-p*henomena @clearp*henomena" none none none@program #16043:@clear-phenomena"Usage:  @clear-phenomena";"  Clears all the phenomena and their details from this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!this.pnames)  return player:tell("There are no phenomena defined on ", this:title(), ".");endifanswer = $command_utils:read(player:tell("Are you sure you want to clear all the phenomena from ", this:title(), "?"));if ($string_utils:find_prefix(answer, {"yes", "1"}))  names = length(this.pnames);  for index in [1..names]    player:tell(this.pnames[index], " cleared.");    $command_utils:suspend_if_needed(0);  endfor  this.pnames = {};  this.pdescs = {};  this.pvalues = {};  this.pdetails = {};  player:tell("All phenomena cleared from ", this:title(), ".");@more relse  player:tell("Clear canceled.");endif"LMB #23230 01/19/2011";.@args #16043:"remove_phenomenon" this none this@program #16043:remove_phenomenonif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifname = args[1];if (index = this:match_phenomenon(name))  p = index[$];  this.pnames = listdelete(this.pnames, p);  this.pdescs = listdelete(this.pdescs, p);  this.pvalues = listdelete(this.pvalues, p);  this.pdetails = listdelete(this.pdetails, p);  return 1;else  return 0;endif"LMB #23230 01/17/2011";.@args #16043:"moveto" this none this@program #16043:movetoif (!this:perm_check(caller))  player:tell("Gravity discourages you from even attempting that.");  return;endifreturn pass(@args);"LMB #23230 01/09/2011";.@args #16043:"sphere ellipsoid torus elliptical_torus" this none this@program #16043:sphere"This verb assumes that the first four values of this.p_shapes are sphere, ellipsoid, torus, and elliptical_torus. If you change them, this verb may not function correctly.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif{name, desc} = args;origin = {-1.0, -1.0, -1.0};data = {};while (origin[1] < 0.0)  `origin[1] = tofloat($command_utils:read(player:tell("Enter a radius for the origin point of ", name, " that is greater than or equal to zero. This is the distance (e.g. in light years) from the origin (e.g. Earth) to the center point of your phenomenon."))) ! E_INVARG => -1';endwhilewhile ((origin[2] < 0.0) || (origin[2] >= 360.0))  `origin[2] = tofloat($command_utils:read(player:tell("Enter an azimuth for the origin point of ", name, " that is greater than or equal to 0 and less than 360. This is the angle, in degrees, between the axis pointing from, e.g., Earth toward, e.g., the center of the galaxy (or universe) and the axis along which your phenomenon lies. The angle increases in a clockwise direction."))) ! E_INVARG => -1';endwhilewhile ((origin[3] < 0.0) || (origin[3] > 180.0))  `origin[3] = tofloat($command_utils:read(player:tell("Enter an inclination for the origin point of ", name, " that is greater than or equal to 0 and less than or equal to 180. This is the angle, in degrees, between e.g. galactic polar north and the axis along which your phenomenon lies. 0 degrees is directly above the galactic plane, 90 degrees is level with the galactic plane, and 180 degrees is directly below this plane."))) ! E_INVARG => -1';endwhileif (verb == "sphere")  radius = 0.0;  while (radius < 0.0)    `radius = tofloat($command_utils:read(player:tell("Enter the radius of the spherical phenomenon called ", name, ". This is the distance from the origin point to the edge of the phenomenon in all directions."))) ! E_INVARG => -1';  endwhile  data = {radius};elseif (verb == "ellipsoid")  semiaxes = {0.0, 0.0, 0.0};  while (semiaxes[1] <= 0.0)    `semiaxes[1] = tofloat($command_utils:read(player:tell("Enter the length of the first semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that lies between the origin point, e.g. Earth, and the center of the galaxy."))) ! E_INVARG => -1';  endwhile  while (semiaxes[2] <= 0.0)    `semiaxes[2] = tofloat($command_utils:read(player:tell("Enter the length of the second semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that is perpendicular to the first semiaxis and level with the galactic plane."))) ! E_INVARG => -1';  endwhile  while (semiaxes[3] <= 0.0)    `semiaxes[3] = tofloat($command_utils:read(player:tell("Enter the length of the third semiaxis of ", name, ". This semiaxis is aligned with the vertical axis that connects the antipodes of the galactic coordinate system. It is perpendicular to the first and second semiaxes and also with the galactic plane."))) ! E_INVARG => -1';  endwhile  data = semiaxes;elseif (verb == "torus")  torus_radius = 0.0;  tube_radius = 0.0;  while (torus_radius <= 0.0)    `torus_radius = tofloat($command_utils:read(player:tell("Enter the radius of the torus-shaped phenomenon called ", name, ". This is the distance from the origin point of the torus to the center of the torus tube."))) ! E_INVARG => -1';  endwhile  while (tube_radius <= 0.0)    `tube_radius = tofloat($command_utils:read(player:tell("Enter the radius of the torus tube for ", name, ". This is the distance from the center of the tube to its outer edge."))) ! E_INVARG => -1';  endwhile  data = {torus_radius, tube_radius};elseif (verb == "elliptical_torus")  semiaxes = {0.0, 0.0};  radius = 0.0;  while (semiaxes[1] <= 0.0)    `semiaxes[1] = tofloat($command_utils:read(player:tell("Enter the length of the first semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that lies between the origin point, e.g. Earth, and the center of the galaxy."))) ! E_INVARG => -1';  endwhile  while (semiaxes[2] <= 0.0)    `semiaxes[2] = tofloat($command_utils:read(player:tell("Enter the length of the second semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that is perpendicular to the first semiaxis and level with the galactic plane."))) ! E_INVARG => -1';  endwhile  while (radius <= 0.0)    `radius = tofloat($command_utils:read(player:tell("Enter the radius of the elliptical torus-shaped phenomenon called ", name, ". This is the distance from the origin point of the elliptical torus to the center of the torus tube."))) ! E_INVARG => -1';  endwhile  data = {@semiaxes, radius};else  player:tell("Error. No phenomenon created. There is a problem with the sphere ellipsoid torus elliptical_torus verb. One or more parts may be missing.");  return;endifshape_index = $string_utils:substitute(verb, {{"_", " "}}) in this.p_shapes;this.pnames = {@this.pnames, name};this.pdescs = {@this.pdescs, desc};this.pvalues = {@this.pvalues, {origin, data, shape_index, 0}};this.pdetails = {@this.pdetails, {}};"Information stored in pvalues = {{radius, azimuth, inclination}, {data specific to each shape such as radius or semiaxis lengths}, index of the shape of the phenomenon in this.p_shapes, speed limit of ships passing through the phenomenon, 0 if none and by default}";"LMB #23230 01/18/2011";.@args #16043:"@add-phenomenon-detail @addphenomenondetail @add-ph-detail @addphdetail @remove-phenomenon-detail @removephenomenondetail @remove-ph-detail @removephdetail @rm-ph-detail @rmphdetail" any any any@program #16043:@add-phenomenon-detail"Usage:  @add-phenomenon-detail <detail> to <phenomenon> | @remove-phenomenon-detail <detail> from <phenomenon>";"  Adds or removes a detail from a cosmic phenomenon defined on this universe. These act like room details when scanned by a ship and add descriptive variety to a phenomenon.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (((!dobjstr) || (!(prepstr && iobjstr))) || (!(args[2] in {"out of", "from inside", "from", "at", "to"})))  return player:tell("Usage: @", (verb[2] == "r") ? "remove-phenomenon-detail <detail> from" | "add-phenomenon-detail <detail> to", " <phenomenon>");endifdetail = args[1];ph = args[3];if (verb[2] == "r")  if (!(ph_match = this:match_phenomenon(ph)))    return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");  endif  results = this:remove_phenomenon_detail(detail, ph);  detail_names = results[1];  ph_names = results[2];  if (!detail_names)    return player:tell("There is no detail called ", detail, " defined on ", this.pnames[ph_match[1]], ".");  else    for removed in [1..length(ph_names)]      player:tell(detail_names[removed], " has been removed from ", ph_names[removed], ".");      $command_utils:suspend_if_needed(0);    endfor    return;  endifelseif (verb[2] == "a")  results = this:match_phenomenon(ph);  detail_results = this:match_phenomenon_detail(detail, results);  if (!results)    return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");  elseif (detail_results[2])    ph_name = this.pnames[results[1]];    detail_name = this.pdetails[detail_results[1][1]][1][detail_results[2][1]];    if ($string_utils:find_prefix($command_utils:read(player:tell("One or more details called ", detail_name, " are already defined on the phenomenon or phenomena called ", ph_name, ". Do you want to write a new description for it/them?")), {"yes", "1"}))      desc = $command_utils:read_lines(player:tell("Enter a new description for ", detail_name, ":"));      for p in (detail_results[1])        for d in (details_results[2])          this.pdetails[p][2][d] = desc;        endfor      endfor      player:tell("Detail description changed.");    else      return player:tell("Command aborted.");    endif  else    desc = $command_utils:read_lines(player:tell("Enter a description for ", detail, ":"));    for p in (results)      if (this.pdetails[p] == {})        this.pdetails[p] = {{}, {}};      endif      this.pdetails[p][1] = {@this.pdetails[p][1], detail};      this.pdetails[p][2] = {@this.pdetails[p][2], desc};      player:tell("New detail added.");      $command_utils:suspend_if_needed(0);    endfor    "This process is not very efficient but isn't meant to be used in inefficient ways too often.";    "That is, if you have multiple phenomena with the same name, because you want to take advantage of overlapping to create complex shapes.";  endifendif"LMB #23230 01/17/2011";.@args #16043:"@add-shape @addshape @remove-shape @removeshape @rmshape" any none none@program #16043:@add-shape"Usage:  @add-shape <shape name> | @remove-shape <shape name>";"  Add or remove the name of a phenomenon shape to the shape name list of this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  return player:tell("Usage:  @", (verb[2] == "r") ? "remove-shape" | "add-shape", " <shape name>");endifshape = argstr;if (verb[2] == "r")  if (index = $string_utils:find_prefix(shape, this.p_shapes))    if (index < 5)      player:tell(this.p_shapes[index], " cannot be removed.");    else      player:tell(this.p_shapes[index], " removed.");      player:tell("If you created any phenomena with the shape ", this.p_shapes[index], ", you must remove them manually. Otherwise, they will be treated as spheres.");      this.p_shapes = listdelete(this.p_shapes, index);    endif  else    player:tell("No shape called ", shape, " has been defined on ", this:title(), ".");  endifelseif (verb[2] == "a")  this.p_shapes = {@this.p_shapes, shape};  player:tell(shape, " has been added to the phenomena shapes list for ", this:title(), ".");endif"LMB #23230 01/15/2011";.@args #16043:"sphere_contains ellipsoid_contains torus_contains elliptical_torus_contains" this none this@more r@program #16043:sphere_contains"Determines whether or not a given point is within the boundaries of a phenomenon with relevant data from this.pvalues.";{data, point} = args;result = 0;if (verb == "sphere_contains")  {x, y, z} = this:convert(point);  {r} = data;  result = ((((x ^ 2.0) + (y ^ 2.0)) + (z ^ 2.0)) <= (r ^ 2.0)) ? 1 | 0;elseif (verb == "ellipsoid_contains")  {a, b, c} = data;  {r, theta, phi} = point;  theta = this:radians(theta);  phi = this:radians(phi);  op1 = (((r ^ 2.0) * (cos(theta) ^ 2.0)) * (sin(phi) ^ 2)) / (a ^ 2.0);  op2 = (((r ^ 2.0) * (sin(theta) ^ 2.0)) * (sin(phi) ^ 2)) / (b ^ 2.0);  op3 = ((r ^ 2.0) * (cos(phi) ^ 2.0)) / (c ^ 2.0);  result = (((op1 + op2) + op3) <= 1.0) ? 1 | 0;elseif (verb == "torus_contains")  {x, y, z} = this:convert(point);  {c, r} = data;  result = (((c - (sqrt((x ^ 2.0) + (y ^ 2.0)) ^ 2.0)) + (z ^ 2.0)) <= (r ^ 2)) ? 1 | 0;elseif (verb == "elliptical_torus_contains")  {x, y, z} = this:convert(point);  {a, b, c} = data;  op1 = (((((a ^ 2.0) * (((z ^ 2.0) / (b ^ 2.0)) - 1.0)) - (c ^ 2.0)) + (x ^ 2.0)) + (y ^ 2.0)) ^ 2.0;  op2 = ((4.0 * (a ^ 2.0)) * (c ^ 2.0)) * (1.0 - ((z ^ 2.0) / (b ^ 2.0)));  return (op1 <= op2) ? 1 | 0;endifreturn result;"LMB #23230 01/19/2011";.@args #16043:"@shapes" none none none@program #16043:@shapes"Usage:  @shapes";"  Lists the available phenomena shapes defined on this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifplayer:tell("Phenomena shapes defined on ", this:title(), ":");for shape in (this.p_shapes)  player:tell(shape);  $command_utils:suspend_if_needed(0);endfor"LMB #23230 01/15/2011";.@args #16043:"remove_phenomenon_detail" this none this@program #16043:remove_phenomenon_detail"Takes as arguments the name of a detail and the name of a phenomenon. Deletes all details that match the given detail name from all phenomena that match the given phenomenon name. Returns two lists, the names of the details deleted and the names of the phenomena deleted. This is a redundant step but designed to remind the player that redundant details are being deleted.";detail = args[1];ph = args[2];ph_list = this:match_phenomenon(ph);detail_list = this:match_phenomenon_detail(detail, ph_list);ph_names = {};detail_names = {};index = 0;for p in (detail_list[1])  index = index + 1;  d = detail_list[2][index];  ph_names = {@ph_names, this.pnames[p]};  detail_names = {@detail_names, this.pdetails[p][1][d]};  this.pdetails[p][1] = listdelete(this.pdetails[p][1], d);  this.pdetails[p][2] = listdelete(this.pdetails[p][2], d);  if (!$list_utils:flatten(this.pdetails[p]))    this.pdetails[p] = $list_utils:flatten(this.pdetails[p]);  endif  $command_utils:suspend_if_needed(0);endforreturn {detail_names, ph_names};"LMB #23230 01/17/2011";.@args #16043:"match_phenomenon" this none this@program #16043:match_phenomenon"Takes as an argument the name of a phenomenon and returns as a list the indexes of all the phenomena that match it which are stored in this.pnames.";ph = args[1];results = {};index = 0;for p in (this.pnames)  index = index + 1;  if (match(p, ph))    results = {@results, index};  endif  $command_utils:suspend_if_needed(0);endforreturn results;"LMB #23230 01/17/2011";.@args #16043:"match_phenomenon_detail" this none this@program #16043:match_phenomenon_detail"Takes as arguments the name of a detail to match and a list of indexes to phenomena stored in this.pnames and usually returned from this:match_phenomenon(). Returns a list of two lists. Each item in the first list is the the index number of a phenomenon that corresponds to the same element in the second list, which is the index number of a detail defined for that phenomenon. E.g., if this function returns {{1, 2}, {1, 1}}, then detail 1 on phenomena 1 (this.pnames[1]) and detail 1 on phenomena 2 match the given detail name. This could have been done in a more straightforward way. Maybe in the next version.";detail = args[1];ph_list = args[2];ph = {};details = {};index = 0;for p_index in (ph_list)  index = 0;  if (this.pdetails[p_index])    for d in (this.pdetails[p_index][1])@more r      index = index + 1;      if (match(d, detail))        ph = {@ph, p_index};        details = {@details, index};      endif      $command_utils:suspend_if_needed(0);    endfor  endif  $command_utils:suspend_if_needed(0);endforreturn {ph, details};"LMB #23230 01/17/2011";.@args #16043:"@clear-phenomena-details @clearphenomenadetails @clear-ph-details @clearphdetails" any any any@program #16043:@clear-phenomena-details"Usage:  @clear-phenomena-details <phenomenon> | @clear-phenomena-details";"  With a phenomenon as an argument, clears all the details from that phenomenon. If no argument is given, all the details for all phenomena are cleared from this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!this.pnames)  return player:tell("There are no phenomena defined on ", this:title(), ".");elseif ($list_utils:flatten(this.pdetails) == {})  return player:tell("There are no details for any phenomena defined on ", this:title(), ".");endifif (!args)  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details from all the phenomena defined on ", this:title(), "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for p in [1..length(this.pnames)]      if (this.pdetails[p])        for d in [1..length(this.pdetails[p][1])]          player:tell(this.pdetails[p][1][d], " cleared from ", this.pnames[p], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[p] = {};        player:tell("All details cleared from ", this.pnames[p], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelseif (ph = this:match_phenomenon(argstr))  if ($list_utils:flatten(this.pdetails[ph[1]]) == {})    return player:tell("There are no details defined on ", this.pnames[ph[1]], ".");  endif  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details defined on ", this.pnames[ph[1]], "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for ph_index in (ph)      if (this.pdetails[ph_index])        details = length(this.pdetails[ph_index][1]);        for d in [1..details]          player:tell(this.pdetails[ph_index][1][d], " cleared from ", this.pnames[ph_index], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[ph_index] = {};        player:tell("All details cleared from ", this.pnames[ph_index], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelse  player:tell("There is no phenomenon called ", argstr, " defined on ", this:title(), ".");endif"LMB #23230 01/18/2011";.@args #16043:"phenomenon" this none this@program #16043:phenomenonindex = args[1];name = this.pnames[index];data = this.pvalues[index][2];shape_index = this.pvalues[index][3];shape = this.p_shapes[shape_index];string = "";if (shape == "sphere")  string = ((name + " has a radius of ") + tostr(data[1])) + ".";elseif (shape == "ellipsoid")  string = ((name + " has three semiaxes of lengths ") + $string_utils:english_list(data)) + ". ";elseif (shape == "torus")  string = ((((name + " has a radius of ") + tostr(data[1])) + " and its tube has a radius of ") + tostr(data[2])) + ".";elseif (shape == "elliptical_torus")  string = ((((((name + " has two semiaxes of lengths ") + tostr(data[1])) + " and ") + tostr(data[2])) + " and a radial semiaxis of ") + tostr(data[3])) + ".";endifreturn string;"LMB #23230 01/19/2011";.@args #16043:"acceptable" this none this@program #16043:acceptablereturn ((this:perm_check(@args) || (caller_perms() == this.owner)) || (caller_perms() == #23230)) && pass(@args);"LMB #23230 01/23/2011";."***finished***