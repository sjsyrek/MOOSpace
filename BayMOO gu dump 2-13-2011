@dump gu@chmod #16043."permitted" ;#16043.("permitted") = {}@chmod #16043."noperms_msg" r;#16043.("noperms_msg") = ""@chmod #16043."pnames" r;#16043.("pnames") = {}@chmod #16043."pdescs" r;#16043.("pdescs") = {}@chmod #16043."pvalues" ;#16043.("pvalues") = 0@chmod #16043."p_shapes" r;#16043.("p_shapes") = {"sphere", "ellipsoid", "torus", "elliptical torus"}@chmod #16043."pdetails" ;#16043.("pdetails") = {};#16043.("help_msg") = "The universe is the place where everything happens--all the action and excitement. It's where all the people are. Basically, anything that could happen happens here. For additional help, see the documentation on the individual verbs. Universes are for advanced users.";#16043.("stars") = {".", "@", "*", "+", "o", ".", "x", "*", "+", ":"}@chmod #16043."pstars" ;#16043.("pstars") = {};#16043.("entrances") = {};#16043.("exits") = {};#16043.("key") = 0;#16043.("aliases") = {"[MOOSpace] Generic Universe", "gu"};#16043.("description") = "A universe in MOOSpace is basically a container for all the space objects within it--a room of rooms that you have to imagine is infinite in extent. According to Richard Bartle, this is the sort of act of fancy that makes text-based virtual worlds superior to graphics-based ones. Universes also have regional features, called phenomena, that can affect starship navigation in various ways. Generally speaking, you won't need to create children of this object (or more than one, at least) unless you want to have your own dimension for ships, etc. to explore. Theoretically, you could create a whole series of universes and string them together into a multiverse, but it would take someone quite a long time to explore it!";#16043.("object_size") = {38354, 1297639179}"#16043.("original_owner") => E_PERM (Permission denied)"#16043.("days_left") => E_PERM (Permission denied);#16043.("creation_date") = 969427835"#16043.("queued_task_limit") => E_PERM (Permission denied)@args #16043:"@add-p*henomenon @addp*henomenon @remove-p*henomenon @removep*henomenon @rm-p*henomenon @rmp*henomenon" any none none@program #16043:@add-phenomenon"Usage:  @add-phenomenon <name> | @remove-phenomenon <name>";"  Adds or removes a cosmic phenomenon to this universe. A phenomenon is an area of space defined according to its shape. The default shapes are sphere, ellipsoid, torus, and elliptical torus. Additional shapes may be defined. A ship within the boundaries of a phenomenon will see a different name and description when it scans its present position in space. Use phenomena for such things as galaxies, star systems, nebulae, or whatever other weird things you can devise. Since phenomena can overlap, you can rearrange them or even add speed limits for ships traveling through them using the @set-phenomenon command.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!dobjstr)  return player:tell("Usage: @", (verb[2] == "r") ? "remove-phenomenon" | "add-phenomenon", " <name>");endifname = dobjstr;if (verb[2] == "r")  if (this:remove_phenomenon(name))    player:tell(name, " has been removed from ", this:title(), ".");  else    player:tell("There is no phenomena called ", name, " defined on ", this:title(), ".");  endifelseif (verb[2] == "a")  if ((name == this:title()) || (name == this.name))    return player:tell("You must choose a phenomenon name that is different from the name of the universe.");  endif  if (results = this:match_phenomenon(name))    index = results[1];    question = (length(results) == 1) ? ((("There is a phenomenon called " + this.pnames[index]) + " already defined on ") + this:title()) + ". Do you want to write a new description for it? Answer 'yes' to replace the description. Otherwise a new phenomenon will be created." | (((((("There are " + length(results)) + " phenomena with the name ") + this.pnames[index]) + " already defined on ") + this:title()) + ". Do you want to write a new description for them? Answer 'yes' to replace the descriptions. Otherwise, a new phenomenon will be created.");    if ($string_utils:find_prefix($command_utils:read(player:tell(question)), {"yes", "1"}))      desc = $command_utils:read_lines(player:tell("Enter a new description for ", this.pnames[index], ":"));      for p in (results)        this.pdescs[p] = desc;        $command_utils:suspend_if_needed(0);      endfor      return player:tell("Description changed.");    endif  endif  player:tell("Enter a description for ", name, ":");  desc = $command_utils:read_lines();  shape = 0;  "If you want to define additional shapes, you should: 1. append the name of the shape as a string to this.p_shapes, 2. create a verb with the same name, replacing any spaces between words with underscores so the verb can be called internally, 3. program the verb collect the necessary values from the player to create the shape and store them in this.pvalues (see the original shape verbs for guidance), 4. create a verb called [shape]_contains where [shape] is the same name used above, and 5. program that verb to take as arguments a list of spherical coordinates in {radius, azimuth, inclination} form and a list of values from this.pvalues and return true if the coordinates are inside the specified phenomenon and false otherwise. This is easier than it sounds.";  while ((shape < 1) || (shape > length(this.p_shapes)))    player:tell("What shape do you want ", name, " to have? Enter a number:");    player:tell();    for sh in [1..length(this.p_shapes)]      player:tell(sh, ". ", this.p_shapes[sh]);    endfor    shape = toint($command_utils:read());  endwhile  shape_name = this.p_shapes[shape];  if ($object_utils:has_callable_verb(this, shape_name = $string_utils:substitute(shape_name, {{" ", "_"}})))    verb = shape_name;    this:(verb)(name, desc);  else    player:tell(this:title(), " is not capable of creating a ", shape_name, ". Command aborted.");    return;  endif  player:tell("A phenomenon called ", name, " shaped like ", ($string_utils:a_or_an(shape_name) + " ") + $string_utils:substitute(shape_name, {{"_", " "}}), " has been added to ", this:title(), ".");endif"LMB #23230 02/13/2011";.@args #16043:"@pheno*mena" none none none@program #16043:@phenomena"Usage:  @phenomena";"  Lists the phenomena defined on this universe and their details.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (this.pnames == {})  player:tell("There are no phenomena defined on ", this:title(), ".");else  player:tell("Phenomena defined on ", this:title(), " (bottom to top):");  index = 0;  for p in (this.pnames)    index = index + 1;    coordinates = ((((("(" + tostr(this.pvalues[index][1][1])) + ", ") + tostr(this.pvalues[index][1][2])) + ", ") + tostr(this.pvalues[index][1][3]))  + ")";    shape = this.p_shapes[this.pvalues[index][3]];    limit_text = ((limit = this.pvalues[index][4]) > 0) ? "a speed limit of warp " + tostr(limit) | "no speed limit";    player:tell(index, ". ", p, " with origin point at coordinates ", coordinates, " shaped like ", $string_utils:a_or_an(shape), " ", shape, " and with ", limit_text, ".");    if (data_string = this:phenomenon(index))      player:tell("   " + data_string);    endif    if ($list_utils:flatten(this.pdetails[index]))      details = {};      for pd in (this.pdetails[index][1])        details = {@details, pd};        $command_utils:suspend_if_needed(0);      endfor      player:tell("   Details defined on ", p, ": ", $string_utils:english_list(details), ".");    endif    $command_utils:suspend_if_needed(0);  endforendif"LMB #23230 01/19/2011";.@args #16043:"distance" this none this@program #16043:distance"Converts two sets of spherical coordinates into Cartesian coordinates and calculates the distance between them. You can hack this procedure for your universe if you want to define your own physics.";{x1, y1, z1} = this:convert(args[1]);{x2, y2, z2} = this:convert(args[2]);distance = sqrt((((x2 - x1) ^ 2.0) + ((y2 - y1) ^ 2.0)) + ((z2 - z1) ^ 2.0));"Because of the limitations of floating point calculations, it is necessary to reduce the precision of the extremely long decimals that will sometimes result from this procedure.";return tofloat(floatstr(distance, 10));"LMB #23230 01/08/2011";.@args #16043:"convert aconvert" this none this@program #16043:convert"The convert() function converts spherical into Cartesian coordinates, and aconvert() is vice versa. The positive x-axis in Cartesian is identical to the projection of 0 degrees of azimuth (theta) in the spherical system, and the positive y-axis is identical to the projection of 0 degrees of inclination (phi).";if (verb == "convert")  {r, theta, phi} = args[1];  if (((!(r >= 0.0)) || (!((theta >= 0.0) && (theta < 360.0)))) || (!((phi >= 0.0) && (phi <= 180.0))))    return E_INVARG;  else    theta = this:radians(theta);    phi = this:radians(phi);    x = (r * cos(theta)) * sin(phi);    y = (r * sin(theta)) * sin(phi);    z = r * cos(phi);    return {x, y, z};  endifelseif (verb == "aconvert")  {x, y, z} = args[1];  r = sqrt(((x ^ 2.0) + (y ^ 2.0)) + (z ^ 2.0));  theta = atan(y, x);  phi = `acos(z / r) ! E_DIV => 0';  "atan() returns a value between -pi and pi, but MOOSpace uses 360 degrees for azimuth, so any values less than zero (that is, in the range 0 to -180 degrees) are simply subtracted from 360 after conversion from radians to degrees.";  theta = (theta < 0.0) ? 360.0 - abs(this:degrees(theta)) | this:degrees(theta);  phi = this:degrees(phi);  return {r, theta, phi};endif"LMB #23230 01/23/2011";.@args #16043:"degrees" this none this@program #16043:degrees"Converts radians into degrees.";return tofloat(args[1]) * 57.2957795130823;"LMB #23230 01/07/2011";.@args #16043:"radians" this none this@program #16043:radians"Converts degrees into radians.";return tofloat(args[1]) * 0.0174532925199433;"LMB #23230 01/07/2011";.@args #16043:"perm_check" this none this@program #16043:perm_check"Takes a single object as an argument, usually the value of caller if passed from the command line and caller_perms() otherwise. Returns true if the object (typically a player) is this, this.owner, listed in this.permitted, or a wizard. Returns false otherwise or if the argument list is the wrong length. This is a permissions check meant to prevent verb spoofing. Every command verb defined on MOOSpace objects should use it. Since it's so important, perm_check() does considerable maintenance on this.permitted whenever it's called.";{?TestCase = 0, @rest} = args;if (!$perm_utils:controls(caller_perms(), this))  return E_PERM;elseif ((typeof(TestCase) != OBJ) || rest)  return E_ARGS;elseif (!$object_utils:has_property(this, "permitted"))  player:tell("** ERROR: The .permitted property on ", this.name, " is either missing or broken.");  return $perm_utils:controls(caller_perms(), this);elseif (typeof(this.permitted) != LIST)  this.permitted = {};endiftrusted_list = {#23230, this};permitted_list = this.permitted;"The for loop below makes sure the objects in this.permitted are valid (i.e. they exist and haven't been recycled) and cleans it up if necessary.";for trusted_object in (permitted_list = $list_utils:remove_duplicates($list_utils:flatten(permitted_list)))  $command_utils:suspend_if_needed(0);  if ((typeof(trusted_object) == OBJ) && $recycler:valid(trusted_object))    trusted_list = {@trusted_list, trusted_object};  else    permitted_list = setremove(permitted_list, trusted_object);  endifendforthis.permitted = permitted_list;return (TestCase in trusted_list) || $perm_utils:controls(TestCase, this);"LMB #23230 02/10/2011";.@args #16043:"@permit @trust" any any any@program #16043:@permit"Usage:  @permit <any player> | @permit -<any player>";"  Commissions a player other than the owner to operate or modify this space object. Only the owner, however, can use this command. Use a minus sign '-' in front of the player's name to decommission that player";if (!$perm_utils:controls(caller, this))  player:tell(this:noperms_msg());  return E_PERM;elseif (!args)  permitted_list = $list_utils:remove_duplicates({this.owner, @this.permitted});  player:tell($string_utils:title_list(permitted_list), (permitted_list == {this.owner}) ? " is " | " are ", $string_utils:pronoun_sub("permitted to operate and modify %t."));elseif (dobjstr[1] == "-")  match = $string_utils:match(dobjstr[2..$], {this.owner, @this.permitted}, "aliases");  if ((match == this.owner) && (this.permitted == {}))    player:tell("You cannot decommission yourself!");  elseif (match in this.permitted)    this.permitted = setremove(this.permitted, match);    player:tell(match:title(), $string_utils:pronoun_sub(" is no longer commissioned to operate or modify %t."));  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  else    player:tell(dobjstr, $string_utils:pronoun_sub(" is not the name of any player currently commissioned to operate and modify %t."));  endifelse  match = $string_utils:match_player(tostr(dobjstr));  if (match == $failed_match)    player:tell("No player called ", dobjstr, " can be found. Try using the player's object number instead.");  elseif (match == $ambiguous_match)    player:tell(dobjstr, " can refer to more than one player. Please be more specific.");  elseif (match in this.permitted)    player:tell(match:title(), $string_utils:pronoun_sub(" is already permitted to operate and modify %t."));  else    this.permitted = {@this.permitted, match};    player:tell(match:title(), $string_utils:pronoun_sub(" is now commissioned to operate and modify %t."));  endifendif"LMB #23230 01/23/2011";.@args #16043:"@set-p*henomenon @setp*henomenon" any any any@program #16043:@set-phenomenon"Usage:  @set-phenomenon <phenomenon> move up/down/top/bottom | @set-phenomenon <phenomenon> to <speed>";"  Rearranges the match order of a phenomenon defined on this universe or changes the maximum speed of ships passing through it. The first usage of the verb is useful if you want, e.g., a default phenomenon of a significant size, like a galaxy, to sit underneath more specific and localized phenomena like nebulae and such which take precedence. The second usage of the verb changes the speed limit of the phenomenon, which might make sense of the phenomenon is meant to represent an area of strong gravity or material density. Changing the speed limit will also affect the maximum sensor range of ships looking out of or into the phenomenon by an equivalent factor.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif{?ph = "", @extra_words, ?do = "", ?parameter = ""} = args;if (extra_words)  ph = (ph + " ") + $string_utils:from_list(extra_words, " ");endifif (ph && (!(p_index = this:match_phenomenon(ph))))  return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");elseif (parameter && (do == "move"))  if (length(this.pnames) == 1)    return player:tell("There is only one phenomenon defined on ", this:title(), ".");  endif  for p in (p_index)    pname = this.pnames[p];    pdesc = this.pdescs[p];    pvalue = this.pvalues[p];    pdetails = this.pdetails[p];    r = 0;    if ((parameter[1] == "u") && (p < length(this.pnames)))      r = p + 1;      player:tell(pname, " moved above ", this.pnames[r], ".");    elseif ((parameter[1] == "d") && (p > 1))      r = p - 1;      player:tell(pname, " moved below ", this.pnames[r], ".");    elseif ((parameter[1] == "t") && (p < length(this.pnames)))      r = length(this.pnames);      player:tell(pname, " moved to the top of the list, above ", this.pnames[r], ".");    elseif ((parameter[1] == "b") && (p > 1))      r = 1;      player:tell(pname, " moved to the bottom of the list, below ", this.pnames[r], ".");    else      player:tell(this.pnames[p], " unchanged.");    endif    if (r)      rname = this.pnames[r];      rdesc = this.pdescs[r];      rvalue = this.pvalues[r];      rdetails = this.pdetails[r];      this.pnames[r] = pname;      this.pnames[p] = rname;      this.pdescs[r] = pdesc;      this.pdescs[p] = rdesc;      this.pvalues[r] = pvalue;      this.pvalues[p] = rvalue;      this.pdetails[r] = pdetails;      this.pdetails[p] = rdetails;      "There must be an easier way of doing this. I suppose I could have written a swapping function, but it's such a low-intensity operation.";    endif    $command_utils:suspend_if_needed(0);  endforelseif ((parameter && (do == "to")) && $string_utils:is_numeric($string_utils:explode(parameter, ".")[1]))  speed = toint(parameter);  for p in (p_index)    if (this.pvalues[p][4] == speed)      return player:tell(this.pnames[p], " is already set to a speed limit of ", speed, ".");    elseif ((speed < 0) || (speed > 10))      return player:tell(speed, " is an invalid speed limit. Enter 0 for no speed limit or a speed of 1-10.");    endif    this.pvalues[p][4] = speed;    player:tell("The speed limit of ", this.pnames[p], " is now warp ", speed, ".");    if (speed == 10)      player:tell("Note: if the speed limit is set to 10, ships will not be able to enter the area of space defined by ", this.pnames[p], ".");    endif    $command_utils:suspend_if_needed(0);  endforelse  return player:tell("Usage:  @set-phenomenon <phenomenon> move up/down/top/bottom | @set-phenomenon <phenomenon> to <speed>");endif"LMB #23230 02/13/2011";.@args #16043:"noperms_msg" this none this@chmod #16043:noperms_msg rx@program #16043:noperms_msg"Copied from Improved Generic-All-In-One Room (#7424):noperms_msg by Rat (#4385) Sat Jan  8 16:58:31 2011 PST";return this.(verb) ? this.(verb) | E_PERM;.@args #16043:"@clear-p*henomena @clearp*henomena" none none none@program #16043:@clear-phenomena"Usage:  @clear-phenomena";"  Clears all the phenomena and their details from this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!this.pnames)  return player:tell("There are no phenomena defined on ", this:title(), ".");endifanswer = $command_utils:read(player:tell("Are you sure you want to clear all the phenomena from ", this:title(), "?"));if ($string_utils:find_prefix(answer, {"yes", "1"}))  names = length(this.pnames);  for index in [1..names]    player:tell(this.pnames[index], " cleared.");    $command_utils:suspend_if_needed(0);  endfor  this.pnames = {};  this.pdescs = {};  this.pvalues = {};  this.pdetails = {};  player:tell("All phenomena cleared from ", this:title(), ".");else  player:tell("Clear canceled.");endif"LMB #23230 01/19/2011";.@args #16043:"remove_phenomenon" this none this@program #16043:remove_phenomenonif (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifname = args[1];if (index = this:match_phenomenon(name))  p = index[$];  this.pnames = listdelete(this.pnames, p);  this.pdescs = listdelete(this.pdescs, p);  this.pvalues = listdelete(this.pvalues, p);  this.pdetails = listdelete(this.pdetails, p);  return 1;else  return 0;endif"LMB #23230 01/17/2011";.@args #16043:"moveto" this none this@program #16043:movetoif (!this:perm_check(caller))  player:tell("Gravity discourages you from even attempting that.");  return;endifreturn pass(@args);"LMB #23230 01/09/2011";.@args #16043:"sphere ellipsoid torus elliptical_torus" this none this@program #16043:sphere"This verb assumes that the first four values of this.p_shapes are sphere, ellipsoid, torus, and elliptical_torus. If you change them, this verb may not function correctly.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endif{name, desc} = args;origin = {-1.0, -1.0, -1.0};data = {};while (origin[1] < 0.0)  `origin[1] = tofloat($command_utils:read(player:tell("Enter a radius for the origin point of ", name, " that is greater than or equal to zero. This is the distance (e.g. in light years) from the origin (e.g. Earth) to the center point of your phenomenon."))) ! E_INVARG => -1';endwhilewhile ((origin[2] < 0.0) || (origin[2] >= 360.0))  `origin[2] = tofloat($command_utils:read(player:tell("Enter an azimuth for the origin point of ", name, " that is greater than or equal to 0 and less than 360. This is the angle, in degrees, between the axis pointing from, e.g., Earth toward, e.g., the center of the galaxy (or universe) and the axis along which your phenomenon lies. The angle increases in a clockwise direction."))) ! E_INVARG => -1';endwhilewhile ((origin[3] < 0.0) || (origin[3] > 180.0))  `origin[3] = tofloat($command_utils:read(player:tell("Enter an inclination for the origin point of ", name, " that is greater than or equal to 0 and less than or equal to 180. This is the angle, in degrees, between e.g. galactic polar north and the axis along which your phenomenon lies. 0 degrees is directly above the galactic plane, 90 degrees is level with the galactic plane, and 180 degrees is directly below this plane."))) ! E_INVARG => -1';endwhileif (verb == "sphere")  radius = 0.0;  while (radius < 0.0)    `radius = tofloat($command_utils:read(player:tell("Enter the radius of the spherical phenomenon called ", name, ". This is the distance from the origin point to the edge of the phenomenon in all directions."))) ! E_INVARG => -1';  endwhile  data = {radius};elseif (verb == "ellipsoid")  semiaxes = {0.0, 0.0, 0.0};  while (semiaxes[1] <= 0.0)    `semiaxes[1] = tofloat($command_utils:read(player:tell("Enter the length of the first semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that lies between the origin point, e.g. Earth, and the center of the galaxy."))) ! E_INVARG => -1';  endwhile  while (semiaxes[2] <= 0.0)    `semiaxes[2] = tofloat($command_utils:read(player:tell("Enter the length of the second semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that is perpendicular to the first semiaxis and level with the galactic plane."))) ! E_INVARG => -1';  endwhile  while (semiaxes[3] <= 0.0)    `semiaxes[3] = tofloat($command_utils:read(player:tell("Enter the length of the third semiaxis of ", name, ". This semiaxis is aligned with the vertical axis that connects the antipodes of the galactic coordinate system. It is perpendicular to the first and second semiaxes and also with the galactic plane."))) ! E_INVARG => -1';  endwhile  data = semiaxes;elseif (verb == "torus")  torus_radius = 0.0;  tube_radius = 0.0;  while (torus_radius <= 0.0)    `torus_radius = tofloat($command_utils:read(player:tell("Enter the radius of the torus-shaped phenomenon called ", name, ". This is the distance from the origin point of the torus to the center of the torus tube."))) ! E_INVARG => -1';  endwhile  while (tube_radius <= 0.0)    `tube_radius = tofloat($command_utils:read(player:tell("Enter the radius of the torus tube for ", name, ". This is the distance from the center of the tube to its outer edge."))) ! E_INVARG => -1';  endwhile  data = {torus_radius, tube_radius};elseif (verb == "elliptical_torus")  semiaxes = {0.0, 0.0};  radius = 0.0;  while (semiaxes[1] <= 0.0)    `semiaxes[1] = tofloat($command_utils:read(player:tell("Enter the length of the first semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that lies between the origin point, e.g. Earth, and the center of the galaxy."))) ! E_INVARG => -1';  endwhile  while (semiaxes[2] <= 0.0)    `semiaxes[2] = tofloat($command_utils:read(player:tell("Enter the length of the second semiaxis of ", name, ". This semiaxis is aligned with the galactic axis that is perpendicular to the first semiaxis and level with the galactic plane."))) ! E_INVARG => -1';  endwhile  while (radius <= 0.0)    `radius = tofloat($command_utils:read(player:tell("Enter the radius of the elliptical torus-shaped phenomenon called ", name, ". This is the distance from the origin point of the elliptical torus to the center of the torus tube."))) ! E_INVARG => -1';  endwhile  data = {@semiaxes, radius};else  player:tell("Error. No phenomenon created. There is a problem with the sphere ellipsoid torus elliptical_torus verb. One or more parts may be missing.");  return;endifshape_index = $string_utils:substitute(verb, {{"_", " "}}) in this.p_shapes;this.pnames = {@this.pnames, name};this.pdescs = {@this.pdescs, desc};this.pvalues = {@this.pvalues, {origin, data, shape_index, 0}};this.pdetails = {@this.pdetails, {}};this.pstars = {@this.pstars, {}};"Information stored in pvalues = {{radius, azimuth, inclination}, {data specific to each shape such as radius or semiaxis lengths}, index of the shape of the phenomenon in this.p_shapes, speed limit of ships passing through the phenomenon, 0 if none and by default}";"LMB #23230 02/13/2011";.@args #16043:"@add-phenomenon-detail @addphenomenondetail @add-ph-detail @addphdetail @remove-phenomenon-detail @removephenomenondetail @remove-ph-detail @removephdetail @rm-ph-detail @rmphdetail" any any any@program #16043:@add-phenomenon-detail"Usage:  @add-phenomenon-detail <detail> to <phenomenon> | @remove-phenomenon-detail <detail> from <phenomenon>";"  Adds or removes a detail from a cosmic phenomenon defined on this universe. These act like room details when scanned by a ship and add descriptive variety to a phenomenon.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (((!dobjstr) || (!(prepstr && iobjstr))) || (!(args[2] in {"out of", "from inside", "from", "at", "to"})))  return player:tell("Usage: @", (verb[2] == "r") ? "remove-phenomenon-detail <detail> from" | "add-phenomenon-detail <detail> to", " <phenomenon>");endifdetail = args[1];ph = args[3];if (verb[2] == "r")  if (!(ph_match = this:match_phenomenon(ph)))    return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");  endif  results = this:remove_phenomenon_detail(detail, ph);  detail_names = results[1];  ph_names = results[2];  if (!detail_names)    return player:tell("There is no detail called ", detail, " defined on ", this.pnames[ph_match[1]], ".");  else    for removed in [1..length(ph_names)]      player:tell(detail_names[removed], " has been removed from ", ph_names[removed], ".");      $command_utils:suspend_if_needed(0);    endfor    return;  endifelseif (verb[2] == "a")  results = this:match_phenomenon(ph);  detail_results = this:match_phenomenon_detail(detail, results);  if (!results)    return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");  elseif (detail_results[2])    ph_name = this.pnames[results[1]];    detail_name = this.pdetails[detail_results[1][1]][1][detail_results[2][1]];    if ($string_utils:find_prefix($command_utils:read(player:tell("One or more details called ", detail_name, " are already defined on the phenomenon or phenomena called ", ph_name, ". Do you want to write a new description for it/them?")), {"yes", "1"}))      desc = $command_utils:read_lines(player:tell("Enter a new description for ", detail_name, ":"));      for p in (detail_results[1])        for d in (details_results[2])          this.pdetails[p][2][d] = desc;        endfor      endfor      player:tell("Detail description changed.");    else      return player:tell("Command aborted.");    endif  else    desc = $command_utils:read_lines(player:tell("Enter a description for ", detail, ":"));    for p in (results)      if (this.pdetails[p] == {})        this.pdetails[p] = {{}, {}};      endif      this.pdetails[p][1] = {@this.pdetails[p][1], detail};      this.pdetails[p][2] = {@this.pdetails[p][2], desc};      player:tell("New detail added.");      $command_utils:suspend_if_needed(0);    endfor    "This process is not very efficient but isn't meant to be used in inefficient ways too often.";    "That is, if you have multiple phenomena with the same name, because you want to take advantage of overlapping to create complex shapes.";  endifendif"LMB #23230 01/17/2011";.@args #16043:"@add-shape @addshape @remove-shape @removeshape @rmshape" any none none@program #16043:@add-shape"Usage:  @add-shape <shape name> | @remove-shape <shape name>";"  Add or remove the name of a phenomenon shape to the shape name list of this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  return player:tell("Usage:  @", (verb[2] == "r") ? "remove-shape" | "add-shape", " <shape name>");endifshape = argstr;if (verb[2] == "r")  if (index = $string_utils:find_prefix(shape, this.p_shapes))    if (index < 5)      player:tell(this.p_shapes[index], " cannot be removed.");    else      player:tell(this.p_shapes[index], " removed.");      player:tell("If you created any phenomena with the shape ", this.p_shapes[index], ", you must remove them manually. Otherwise, they will be treated as spheres.");      this.p_shapes = listdelete(this.p_shapes, index);    endif  else    player:tell("No shape called ", shape, " has been defined on ", this:title(), ".");  endifelseif (verb[2] == "a")  this.p_shapes = {@this.p_shapes, shape};  player:tell(shape, " has been added to the phenomena shapes list for ", this:title(), ".");endif"LMB #23230 01/15/2011";.@args #16043:"sphere_contains ellipsoid_contains torus_contains elliptical_torus_contains" this none this@program #16043:sphere_contains"Determines whether or not a given point is within the boundaries of a phenomenon with relevant data from this.pvalues.";{data, point} = args;result = 0;if (verb == "sphere_contains")  {x, y, z} = this:convert(point);  {r} = data;  result = ((((x ^ 2.0) + (y ^ 2.0)) + (z ^ 2.0)) <= (r ^ 2.0)) ? 1 | 0;elseif (verb == "ellipsoid_contains")  {a, b, c} = data;  {r, theta, phi} = point;  theta = this:radians(theta);  phi = this:radians(phi);  op1 = (((r ^ 2.0) * (cos(theta) ^ 2.0)) * (sin(phi) ^ 2)) / (a ^ 2.0);  op2 = (((r ^ 2.0) * (sin(theta) ^ 2.0)) * (sin(phi) ^ 2)) / (b ^ 2.0);  op3 = ((r ^ 2.0) * (cos(phi) ^ 2.0)) / (c ^ 2.0);  result = (((op1 + op2) + op3) <= 1.0) ? 1 | 0;elseif (verb == "torus_contains")  {x, y, z} = this:convert(point);  {c, r} = data;  result = (((c - (sqrt((x ^ 2.0) + (y ^ 2.0)) ^ 2.0)) + (z ^ 2.0)) <= (r ^ 2)) ? 1 | 0;elseif (verb == "elliptical_torus_contains")  {x, y, z} = this:convert(point);  {a, b, c} = data;  op1 = (((((a ^ 2.0) * (((z ^ 2.0) / (b ^ 2.0)) - 1.0)) - (c ^ 2.0)) + (x ^ 2.0)) + (y ^ 2.0)) ^ 2.0;  op2 = ((4.0 * (a ^ 2.0)) * (c ^ 2.0)) * (1.0 - ((z ^ 2.0) / (b ^ 2.0)));  return (op1 <= op2) ? 1 | 0;endifreturn result;"LMB #23230 01/19/2011";.@args #16043:"@shapes" none none none@program #16043:@shapes"Usage:  @shapes";"  Lists the available phenomena shapes defined on this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifplayer:tell("Phenomena shapes defined on ", this:title(), ":");for shape in (this.p_shapes)  player:tell(shape);  $command_utils:suspend_if_needed(0);endfor"LMB #23230 01/15/2011";.@args #16043:"remove_phenomenon_detail" this none this@program #16043:remove_phenomenon_detail"Takes as arguments the name of a detail and the name of a phenomenon. Deletes all details that match the given detail name from all phenomena that match the given phenomenon name. Returns two lists, the names of the details deleted and the names of the phenomena deleted. This is a redundant step but designed to remind the player that redundant details are being deleted.";detail = args[1];ph = args[2];ph_list = this:match_phenomenon(ph);detail_list = this:match_phenomenon_detail(detail, ph_list);ph_names = {};detail_names = {};index = 0;for p in (detail_list[1])  index = index + 1;  d = detail_list[2][index];  ph_names = {@ph_names, this.pnames[p]};  detail_names = {@detail_names, this.pdetails[p][1][d]};  this.pdetails[p][1] = listdelete(this.pdetails[p][1], d);  this.pdetails[p][2] = listdelete(this.pdetails[p][2], d);  if (!$list_utils:flatten(this.pdetails[p]))    this.pdetails[p] = $list_utils:flatten(this.pdetails[p]);  endif  $command_utils:suspend_if_needed(0);endforreturn {detail_names, ph_names};"LMB #23230 01/17/2011";.@args #16043:"match_phenomenon" this none this@program #16043:match_phenomenon"Takes as an argument the name of a phenomenon and returns as a list the indexes of all the phenomena that match it which are stored in this.pnames.";ph = args[1];results = {};index = 0;for p in (this.pnames)  index = index + 1;  if (match(p, ph))    results = {@results, index};  endif  $command_utils:suspend_if_needed(0);endforreturn results;"LMB #23230 01/17/2011";.@args #16043:"match_phenomenon_detail" this none this@program #16043:match_phenomenon_detail"Takes as arguments the name of a detail to match and a list of indexes to phenomena stored in this.pnames and usually returned from this:match_phenomenon(). Returns a list of two lists. Each item in the first list is the the index number of a phenomenon that corresponds to the same element in the second list, which is the index number of a detail defined for that phenomenon. E.g., if this function returns {{1, 2}, {1, 1}}, then detail 1 on phenomena 1 (this.pnames[1]) and detail 1 on phenomena 2 match the given detail name. This could have been done in a more straightforward way. Maybe in the next version.";detail = args[1];ph_list = args[2];ph = {};details = {};index = 0;for p_index in (ph_list)  index = 0;  if (this.pdetails[p_index])    for d in (this.pdetails[p_index][1])      index = index + 1;      if (match(d, detail))        ph = {@ph, p_index};        details = {@details, index};      endif      $command_utils:suspend_if_needed(0);    endfor  endif  $command_utils:suspend_if_needed(0);endforreturn {ph, details};"LMB #23230 01/17/2011";.@args #16043:"@clear-phenomena-details @clearphenomenadetails @clear-ph-details @clearphdetails" any any any@program #16043:@clear-phenomena-details"Usage:  @clear-phenomena-details <phenomenon> | @clear-phenomena-details";"  With a phenomenon as an argument, clears all the details from that phenomenon. If no argument is given, all the details for all phenomena are cleared from this universe.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!this.pnames)  return player:tell("There are no phenomena defined on ", this:title(), ".");elseif ($list_utils:flatten(this.pdetails) == {})  return player:tell("There are no details for any phenomena defined on ", this:title(), ".");endifif (!args)  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details from all the phenomena defined on ", this:title(), "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for p in [1..length(this.pnames)]      if (this.pdetails[p])        for d in [1..length(this.pdetails[p][1])]          player:tell(this.pdetails[p][1][d], " cleared from ", this.pnames[p], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[p] = {};        player:tell("All details cleared from ", this.pnames[p], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelseif (ph = this:match_phenomenon(argstr))  if ($list_utils:flatten(this.pdetails[ph[1]]) == {})    return player:tell("There are no details defined on ", this.pnames[ph[1]], ".");  endif  answer = $command_utils:read(player:tell("Are you sure you want to clear all the details defined on ", this.pnames[ph[1]], "?"));  if ($string_utils:find_prefix(answer, {"yes", "1"}))    for ph_index in (ph)      if (this.pdetails[ph_index])        details = length(this.pdetails[ph_index][1]);        for d in [1..details]          player:tell(this.pdetails[ph_index][1][d], " cleared from ", this.pnames[ph_index], ".");          $command_utils:suspend_if_needed(0);        endfor        this.pdetails[ph_index] = {};        player:tell("All details cleared from ", this.pnames[ph_index], ".");      endif      $command_utils:suspend_if_needed(0);    endfor  else    return player:tell("Clear canceled.");  endifelse  player:tell("There is no phenomenon called ", argstr, " defined on ", this:title(), ".");endif"LMB #23230 01/18/2011";.@args #16043:"phenomenon" this none this@program #16043:phenomenonindex = args[1];name = this.pnames[index];data = this.pvalues[index][2];shape_index = this.pvalues[index][3];shape = this.p_shapes[shape_index];string = "";if (shape == "sphere")  string = ((name + " has a radius of ") + tostr(data[1])) + ".";elseif (shape == "ellipsoid")  string = ((name + " has three semiaxes of lengths ") + $string_utils:english_list(data)) + ". ";elseif (shape == "torus")  string = ((((name + " has a radius of ") + tostr(data[1])) + " and its tube has a radius of ") + tostr(data[2])) + ".";elseif (shape == "elliptical_torus")  string = ((((((name + " has two semiaxes of lengths ") + tostr(data[1])) + " and ") + tostr(data[2])) + " and a radial semiaxis of ") + tostr(data[3])) + ".";endifreturn string;"LMB #23230 01/19/2011";.@args #16043:"acceptable" this none this@program #16043:acceptablereturn ((this:perm_check(@args) || (caller_perms() == this.owner)) || (caller_perms() == #23230)) && pass(@args);"LMB #23230 01/23/2011";.@args #16043:"@set-stars @setstars" any any any@program #16043:@set-stars"Usage:  @set-stars <phenomenon>";"  Sets the stars to be displayed when a ship passes through a phenomenon.";if (!this:perm_check(caller))  player:tell(this:noperms_msg());  return E_PERM;endifif (!args)  return player:tell("Usage:  @set-stars <phenomenon>");endifph = argstr;if (!(p_index = this:match_phenomenon(ph)))  return player:tell("There is no phenomenon called ", ph, " defined on ", this:title(), ".");else  slice = `$list_utils:slice(this.pstars, p_index) ! ANY => 0';  if (slice)    player:tell("The stars currently defined on ", this:title(), " are:");    player:tell($string_utils:from_list(this.pstars[1], " "));    if (!$string_utils:find_prefix($command_utils:read(player:tell("Do you want to overwrite them?")), {"yes", "0"}))      return player:tell("Command aborted.");    endif  endif  player:tell("Input new stars, one star per line. You may use ANSI codes, but make sure to put a  tag after each one. Each star has a one percent chance of appearing. If you input more than 100 stars, each star will appear with less than 1 percent frequency but a star will definitely appear everywhere one can.");  stars = $command_utils:read_lines();  for p in (p_index)    this.pstars[p] = stars;    $command_utils:suspend_if_needed(0);  endfor  player:tell("Stars changed for ", this.pnames[$string_utils:find_prefix(ph, this.pnames)], ".");endif"LMB #23230 02/13/2011";."***finished***